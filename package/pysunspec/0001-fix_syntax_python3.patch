diff --git a/doc/conf.py b/doc/conf.py
index 2566a21..792283a 100644
--- a/doc/conf.py
+++ b/doc/conf.py
@@ -29,7 +29,7 @@ sys.path.insert(0, os.path.abspath('..'))
 # extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
 # ones.
 extensions = [
-    'sphinx.ext.autodoc',
+	'sphinx.ext.autodoc',
 ]
 
 autodoc_member_order = 'bysource'
@@ -230,8 +230,8 @@ latex_documents = [
 # One entry per manual page. List of tuples
 # (source start file, name, description, authors, manual section).
 man_pages = [
-    ('index', 'pysunspec', u'pySunSpec Documentation',
-     [u'SunSpec Alliance'], 1)
+	('index', 'pysunspec', u'pySunSpec Documentation',
+	 [u'SunSpec Alliance'], 1)
 ]
 
 # If true, show URL addresses after external links.
diff --git a/scripts/pysunspec_test.py b/scripts/pysunspec_test.py
index 8a3396c..48e2e69 100644
--- a/scripts/pysunspec_test.py
+++ b/scripts/pysunspec_test.py
@@ -10,5 +10,5 @@ import sunspec.core.test.test_all as test
 
 if __name__ == "__main__":
 
-    test.test_all()
+	test.test_all()
 
diff --git a/scripts/suns.py b/scripts/suns.py
index 2df80b1..0069dda 100644
--- a/scripts/suns.py
+++ b/scripts/suns.py
@@ -15,103 +15,103 @@ from optparse import OptionParser
 """
   Original suns options:
 
-      -o: output mode for data (text, xml)
-      -x: export model description (slang, xml)
-      -t: transport type: tcp or rtu (default: tcp)
-      -a: modbus slave address (default: 1)
-      -i: ip address to use for modbus tcp (default: localhost)
-      -P: port number for modbus tcp (default: 502)
-      -p: serial port for modbus rtu (default: /dev/ttyUSB0)
-      -b: baud rate for modbus rtu (default: 9600)
-      -T: timeout, in seconds (can be fractional, such as 1.5; default: 2.0)
-      -r: number of retries attempted for each modbus read
-      -m: specify model file
-      -M: specify directory containing model files
-      -s: run as a test server
-      -I: logger id (for sunspec logger xml output)
-      -N: logger id namespace (for sunspec logger xml output, defaults to 'mac')
-      -l: limit number of registers requested in a single read (max is 125)
-      -c: check models for internal consistency then exit
-      -v: verbose level (up to -vvvv for most verbose)
-      -V: print current release number and exit
+	  -o: output mode for data (text, xml)
+	  -x: export model description (slang, xml)
+	  -t: transport type: tcp or rtu (default: tcp)
+	  -a: modbus slave address (default: 1)
+	  -i: ip address to use for modbus tcp (default: localhost)
+	  -P: port number for modbus tcp (default: 502)
+	  -p: serial port for modbus rtu (default: /dev/ttyUSB0)
+	  -b: baud rate for modbus rtu (default: 9600)
+	  -T: timeout, in seconds (can be fractional, such as 1.5; default: 2.0)
+	  -r: number of retries attempted for each modbus read
+	  -m: specify model file
+	  -M: specify directory containing model files
+	  -s: run as a test server
+	  -I: logger id (for sunspec logger xml output)
+	  -N: logger id namespace (for sunspec logger xml output, defaults to 'mac')
+	  -l: limit number of registers requested in a single read (max is 125)
+	  -c: check models for internal consistency then exit
+	  -v: verbose level (up to -vvvv for most verbose)
+	  -V: print current release number and exit
 """
 
 if __name__ == "__main__":
 
-    usage = 'usage: %prog [options]'
-    parser = OptionParser(usage=usage)
-    parser.add_option('-t', metavar=' ',
-                      default='tcp',
-                      help='transport type: rtu, tcp, mapped [default: tcp]')
-    parser.add_option('-a', metavar=' ', type='int',
-                      default=1,
-                      help='modbus slave address [default: 1]')
-    parser.add_option('-i', metavar=' ',
-                      default='localhost',
-                      help='ip address to use for modbus tcp [default: localhost]')
-    parser.add_option('-P', metavar=' ', type='int',
-                      default=502,
-                      help='port number for modbus tcp [default: 502]')
-    parser.add_option('-p', metavar=' ',
-                      default='/dev/ttyUSB0',
-                      help='serial port for modbus rtu [default: /dev/ttyUSB0]')
-    parser.add_option('-b', metavar=' ',
-                      default=9600,
-                      help='baud rate for modbus rtu [default: 9600]')
-    parser.add_option('-T', metavar=' ', type='float',
-                      default=2.0,
-                      help='timeout, in seconds (can be fractional, such as 1.5) [default: 2.0]')
-    parser.add_option('-m', metavar=' ',
-                      help='modbus map file')
+	usage = 'usage: %prog [options]'
+	parser = OptionParser(usage=usage)
+	parser.add_option('-t', metavar=' ',
+					  default='tcp',
+					  help='transport type: rtu, tcp, mapped [default: tcp]')
+	parser.add_option('-a', metavar=' ', type='int',
+					  default=1,
+					  help='modbus slave address [default: 1]')
+	parser.add_option('-i', metavar=' ',
+					  default='localhost',
+					  help='ip address to use for modbus tcp [default: localhost]')
+	parser.add_option('-P', metavar=' ', type='int',
+					  default=502,
+					  help='port number for modbus tcp [default: 502]')
+	parser.add_option('-p', metavar=' ',
+					  default='/dev/ttyUSB0',
+					  help='serial port for modbus rtu [default: /dev/ttyUSB0]')
+	parser.add_option('-b', metavar=' ',
+					  default=9600,
+					  help='baud rate for modbus rtu [default: 9600]')
+	parser.add_option('-T', metavar=' ', type='float',
+					  default=2.0,
+					  help='timeout, in seconds (can be fractional, such as 1.5) [default: 2.0]')
+	parser.add_option('-m', metavar=' ',
+					  help='modbus map file')
 
-    options, args = parser.parse_args()
+	options, args = parser.parse_args()
 
-    try:
-        if options.t == 'tcp':
-            sd = client.SunSpecClientDevice(client.TCP, options.a, ipaddr=options.i, ipport=options.P, timeout=options.T)
-        elif options.t == 'rtu':
-            sd = client.SunSpecClientDevice(client.RTU, options.a, name=options.p, baudrate=options.b, timeout=options.T)
-        elif options.t == 'mapped':
-            sd = client.SunSpecClientDevice(client.MAPPED, options.a, name=options.m)
-        else:
-            print 'Unknown -t option: %s' % (options.t)
-            sys.exit(1)
+	try:
+		if options.t == 'tcp':
+			sd = client.SunSpecClientDevice(client.TCP, options.a, ipaddr=options.i, ipport=options.P, timeout=options.T)
+		elif options.t == 'rtu':
+			sd = client.SunSpecClientDevice(client.RTU, options.a, name=options.p, baudrate=options.b, timeout=options.T)
+		elif options.t == 'mapped':
+			sd = client.SunSpecClientDevice(client.MAPPED, options.a, name=options.m)
+		else:
+			print('Unknown -t option: %s' % (options.t))
+			sys.exit(1)
 
-    except client.SunSpecClientError, e:
-        print 'Error: %s' % (e)
-        sys.exit(1)
+	except client.SunSpecClientError as e:
+		print('Error: %s' % (e))
+		sys.exit(1)
 
-    if sd is not None:
-        print '\nTimestamp: %s' % (time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()))
+	if sd is not None:
+		print('\nTimestamp: %s' % (time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())))
 
-        # read all models in the device
-        sd.read()
+		# read all models in the device
+		sd.read()
 
-        for model in sd.device.models_list:
-            if model.model_type.label:
-                label = '%s (%s)' % (model.model_type.label, str(model.id))
-            else:
-                label = '(%s)' % (str(model.id))
-            print '\nmodel: %s\n' % (label)
-            for block in model.blocks:
-                if block.index > 0:
-                  index = '%02d:' % (block.index)
-                else:
-                  index = '   '
-                for point in block.points_list:
-                    if point.value is not None:
-                        if point.point_type.label:
-                            label = '   %s%s (%s):' % (index, point.point_type.label, point.point_type.id)
-                        else:
-                            label = '   %s(%s):' % (index, point.point_type.id)
-                        units = point.point_type.units
-                        if units is None:
-                            units = ''
-                        if point.point_type.type == suns.SUNS_TYPE_BITFIELD16:
-                            value = '0x%04x' % (point.value)
-                        elif point.point_type.type == suns.SUNS_TYPE_BITFIELD32:
-                            value = '0x%08x' % (point.value)
-                        else:
-                            value = str(point.value).rstrip('\0')
-                        print '%-40s %20s %-10s' % (label, value, str(units))
+		for model in sd.device.models_list:
+			if model.model_type.label:
+				label = '%s (%s)' % (model.model_type.label, str(model.id))
+			else:
+				label = '(%s)' % (str(model.id))
+			print('\nmodel: %s\n' % (label))
+			for block in model.blocks:
+				if block.index > 0:
+				  index = '%02d:' % (block.index)
+				else:
+				  index = '   '
+				for point in block.points_list:
+					if point.value is not None:
+						if point.point_type.label:
+							label = '   %s%s (%s):' % (index, point.point_type.label, point.point_type.id)
+						else:
+							label = '   %s(%s):' % (index, point.point_type.id)
+						units = point.point_type.units
+						if units is None:
+							units = ''
+						if point.point_type.type == suns.SUNS_TYPE_BITFIELD16:
+							value = '0x%04x' % (point.value)
+						elif point.point_type.type == suns.SUNS_TYPE_BITFIELD32:
+							value = '0x%08x' % (point.value)
+						else:
+							value = str(point.value).rstrip('\0')
+						print('%-40s %20s %-10s' % (label, value, str(units)))
 
diff --git a/setup.py b/setup.py
index f01fddf..2be28e1 100644
--- a/setup.py
+++ b/setup.py
@@ -8,11 +8,11 @@
 from distutils.core import setup
 
 setup(name = 'pysunspec',
-      version = '1.0.8',
-      description = 'Python SunSpec Tools',
-      author = ['Bob Fox'],
-      author_email = ['bob.fox@loggerware.com'],
-      packages = ['sunspec', 'sunspec.core', 'sunspec.core.modbus', 'sunspec.core.test', 'sunspec.core.test.fake'],
-      package_data = {'sunspec': ['models/smdx/*'], 'sunspec.core.test': ['devices/*']},
-      scripts = ['scripts/suns.py', 'scripts/pysunspec_test.py']
-      )
\ No newline at end of file
+	  version = '1.0.8',
+	  description = 'Python SunSpec Tools',
+	  author = ['Bob Fox'],
+	  author_email = ['bob.fox@loggerware.com'],
+	  packages = ['sunspec', 'sunspec.core', 'sunspec.core.modbus', 'sunspec.core.test', 'sunspec.core.test.fake'],
+	  package_data = {'sunspec': ['models/smdx/*'], 'sunspec.core.test': ['devices/*']},
+	  scripts = ['scripts/suns.py', 'scripts/pysunspec_test.py']
+	  )
\ No newline at end of file
diff --git a/sunspec/core/client.py b/sunspec/core/client.py
index 1e8961b..9d715c0 100644
--- a/sunspec/core/client.py
+++ b/sunspec/core/client.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2017 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import os
@@ -37,459 +37,459 @@ PARITY_NONE = modbus.PARITY_NONE
 PARITY_EVEN = modbus.PARITY_EVEN
 
 class SunSpecClientError(SunSpecError):
-    pass
+	pass
 
 class ClientDevice(device.Device):
 
-    def __init__(self, device_type, slave_id=None, name=None, pathlist = None, baudrate=None, parity=None, ipaddr=None, ipport=None,
-                 timeout=None, trace=False):
-
-        device.Device.__init__(self, addr=None)
-
-        self.type = device_type
-        self.name = name
-        self.pathlist = pathlist
-        self.slave_id = slave_id
-        self.modbus_device = None
-        self.retry_count = 2
-        self.base_addr_list = [40000, 0, 50000]
-
-        try:
-            if device_type == RTU:
-                self.modbus_device = modbus.ModbusClientDeviceRTU(slave_id, name, baudrate, parity, timeout, self, trace)
-            elif device_type == TCP:
-                self.modbus_device = modbus.ModbusClientDeviceTCP(slave_id, ipaddr, ipport, timeout, self, trace)
-            elif device_type == MAPPED:
-                if name is not None:
-                    self.modbus_device = modbus.ModbusClientDeviceMapped(slave_id, name, pathlist, self)
-                else:
-                    if self.modbus_device is not None:
-                        self.modbus_device.close()
-                    raise SunSpecClientError('Map file required for mapped device')
-        except modbus.ModbusClientError, e:
-            if self.modbus_device is not None:
-                self.modbus_device.close()
-            raise SunSpecClientError('Modbus error: %s' % str(e))
-
-    def close(self):
-
-        if self.modbus_device is not None:
-            self.modbus_device.close()
-
-    def read(self, addr, count):
-        try:
-            if self.modbus_device is not None:
-                return self.modbus_device.read(addr, count)
-            else:
-                raise SunSpecClientError('No modbus device set for SunSpec device')
-        except modbus.ModbusClientError, e:
-            raise SunSpecClientError('Modbus read error: %s' % str(e))
-
-    def write(self, addr, data):
-
-        try:
-            if self.modbus_device is not None:
-                return self.modbus_device.write(addr, data)
-            else:
-                raise SunSpecClientError('No modbus device set for SunSpec device')
-        except modbus.ModbusClientError, e:
-            raise SunSpecClientError('Modbus write error: %s' % str(e))
-
-    def read_points(self):
-
-        for model in self.models_list:
-            model.read_points()
-
-    def scan(self, progress=None, delay=None):
-
-        error = ''
-
-        connect = False
-        if self.modbus_device and type(self.modbus_device) == modbus.ModbusClientDeviceTCP:
-            self.modbus_device.connect()
-            connect = True
-
-            if delay is not None:
-                time.sleep(delay)
-
-        if self.base_addr is None:
-            for addr in self.base_addr_list:
-                # print 'trying base address %s' % (addr)
-                try:
-                    data = self.read(addr, 3)
-
-                    if data[:4] == 'SunS':
-                        self.base_addr = addr
-                        # print 'device base address = %d' % self.base_addr
-                        break
-                    else:
-                        error = 'Device responded - not SunSpec register map'
-                except SunSpecClientError, e:
-                    if not error:
-                        error = str(e)
-
-                if delay is not None:
-                    time.sleep(delay)
-
-        if self.base_addr is not None:
-            # print 'base address = %s' % (self.base_addr)
-            model_id = util.data_to_u16(data[4:6])
-            addr = self.base_addr + 2
-
-            while model_id != suns.SUNS_END_MODEL_ID:
-                # read model and model len separately due to some devices not supplying
-                # count for the end model id
-                data = self.read(addr + 1, 1)
-                if data and len(data) == 2:
-                    if progress is not None:
-                        cont = progress('Scanning model %s' % (model_id))
-                        if not cont:
-                            raise SunSpecClientError('Device scan terminated')
-                    model_len = util.data_to_u16(data)
-                    # print 'model_id = %s  model_len = %s' % (model_id, model_len)
-
-                    # move address past model id and length
-                    model = ClientModel(self, model_id, addr + 2, model_len)
-                    # print 'loading model %s at %d' % (model_id, addr + 2)
-                    try:
-                        model.load()
-                    except Exception, e:
-                        model.load_error = str(e)
-                    self.add_model(model)
-
-                    addr += model_len + 2
-                    data = self.read(addr, 1)
-                    if data and len(data) == 2:
-                        model_id = util.data_to_u16(data)
-                    else:
-                        break
-                else:
-                    break
-
-                if delay is not None:
-                    time.sleep(delay)
-
-        else:
-            if not error:
-                error = 'Unknown error'
-            raise SunSpecClientError(error)
-
-        if connect:
-            self.modbus_device.disconnect()
+	def __init__(self, device_type, slave_id=None, name=None, pathlist = None, baudrate=None, parity=None, ipaddr=None, ipport=None,
+				 timeout=None, trace=False):
+
+		device.Device.__init__(self, addr=None)
+
+		self.type = device_type
+		self.name = name
+		self.pathlist = pathlist
+		self.slave_id = slave_id
+		self.modbus_device = None
+		self.retry_count = 2
+		self.base_addr_list = [40000, 0, 50000]
+
+		try:
+			if device_type == RTU:
+				self.modbus_device = modbus.ModbusClientDeviceRTU(slave_id, name, baudrate, parity, timeout, self, trace)
+			elif device_type == TCP:
+				self.modbus_device = modbus.ModbusClientDeviceTCP(slave_id, ipaddr, ipport, timeout, self, trace)
+			elif device_type == MAPPED:
+				if name is not None:
+					self.modbus_device = modbus.ModbusClientDeviceMapped(slave_id, name, pathlist, self)
+				else:
+					if self.modbus_device is not None:
+						self.modbus_device.close()
+					raise SunSpecClientError('Map file required for mapped device')
+		except modbus.ModbusClientError as e:
+			if self.modbus_device is not None:
+				self.modbus_device.close()
+			raise SunSpecClientError('Modbus error: %s' % str(e))
+
+	def close(self):
+
+		if self.modbus_device is not None:
+			self.modbus_device.close()
+
+	def read(self, addr, count):
+		try:
+			if self.modbus_device is not None:
+				return self.modbus_device.read(addr, count)
+			else:
+				raise SunSpecClientError('No modbus device set for SunSpec device')
+		except modbus.ModbusClientError as e:
+			raise SunSpecClientError('Modbus read error: %s' % str(e))
+
+	def write(self, addr, data):
+
+		try:
+			if self.modbus_device is not None:
+				return self.modbus_device.write(addr, data)
+			else:
+				raise SunSpecClientError('No modbus device set for SunSpec device')
+		except modbus.ModbusClientError as e:
+			raise SunSpecClientError('Modbus write error: %s' % str(e))
+
+	def read_points(self):
+
+		for model in self.models_list:
+			model.read_points()
+
+	def scan(self, progress=None, delay=None):
+
+		error = ''
+
+		connect = False
+		if self.modbus_device and type(self.modbus_device) == modbus.ModbusClientDeviceTCP:
+			self.modbus_device.connect()
+			connect = True
+
+			if delay is not None:
+				time.sleep(delay)
+
+		if self.base_addr is None:
+			for addr in self.base_addr_list:
+				# print 'trying base address %s' % (addr)
+				try:
+					data = self.read(addr, 3)
+
+					if data[:4] == 'SunS':
+						self.base_addr = addr
+						# print 'device base address = %d' % self.base_addr
+						break
+					else:
+						error = 'Device responded - not SunSpec register map'
+				except SunSpecClientError as e:
+					if not error:
+						error = str(e)
+
+				if delay is not None:
+					time.sleep(delay)
+
+		if self.base_addr is not None:
+			# print 'base address = %s' % (self.base_addr)
+			model_id = util.data_to_u16(data[4:6])
+			addr = self.base_addr + 2
+
+			while model_id != suns.SUNS_END_MODEL_ID:
+				# read model and model len separately due to some devices not supplying
+				# count for the end model id
+				data = self.read(addr + 1, 1)
+				if data and len(data) == 2:
+					if progress is not None:
+						cont = progress('Scanning model %s' % (model_id))
+						if not cont:
+							raise SunSpecClientError('Device scan terminated')
+					model_len = util.data_to_u16(data)
+					# print 'model_id = %s  model_len = %s' % (model_id, model_len)
+
+					# move address past model id and length
+					model = ClientModel(self, model_id, addr + 2, model_len)
+					# print 'loading model %s at %d' % (model_id, addr + 2)
+					try:
+						model.load()
+					except Exception as e:
+						model.load_error = str(e)
+					self.add_model(model)
+
+					addr += model_len + 2
+					data = self.read(addr, 1)
+					if data and len(data) == 2:
+						model_id = util.data_to_u16(data)
+					else:
+						break
+				else:
+					break
+
+				if delay is not None:
+					time.sleep(delay)
+
+		else:
+			if not error:
+				error = 'Unknown error'
+			raise SunSpecClientError(error)
+
+		if connect:
+			self.modbus_device.disconnect()
 
 class ClientModel(device.Model):
 
-    def __init__(self, dev=None, mid=None, addr=0, mlen=None, index=1):
-
-        device.Model.__init__(self, device=dev, mid=mid, addr=addr, mlen=mlen, index=index)
-
-    def load(self):
-
-        device.Model.load(self, block_class=ClientBlock, point_class=ClientPoint)
-
-    def read_points(self):
-
-        if self.model_type is not None:
-            # read current model
-            try:
-                end_index = len(self.read_blocks)
-                if end_index == 1:
-                    data = self.device.read(self.addr, self.len)
-                else:
-                    data = ''
-                    index = 0
-                    while index < end_index:
-                        addr = self.read_blocks[index]
-                        index += 1
-                        if index < end_index:
-                            read_len = self.read_blocks[index] - addr
-                        else:
-                            read_len = self.addr + self.len - addr
-                        data += self.device.read(addr, read_len)
-                if data:
-                    # print 'data len = ', len(data)
-                    data_len = len(data)/2
-                    if data_len != self.len:
-                        raise SunSpecClientError('Error reading model %s' % self.model_type)
-
-                    #  for each repeating block
-                    for block in self.blocks:
-                        # scale factor points
-                        for pname, point in block.points_sf.iteritems():
-                            offset = int(point.addr) - int(self.addr)
-                            if point.point_type.data_to is not None:
-                                byte_offset = offset * 2
-                                # print pname, point, offset, byte_offset, (byte_offset + (int(point.point_type.len) * 2)), point.point_type.len
-                                point.value_base = point.point_type.data_to(data[byte_offset:byte_offset + (int(point.point_type.len) * 2)])
-                                if not point.point_type.is_impl(point.value_base):
-                                    point.value_base = None
-                            else:
-                                raise SunSpecClientError('No data_to function set for %s : %s' % (pname, point.point_type))
-
-                        # non-scale factor points
-                        for pname, point in block.points.iteritems():
-                            offset = int(point.addr) - int(self.addr)
-                            if point.point_type.data_to is not None:
-                                byte_offset = offset * 2
-                                # print pname, point, offset, byte_offset, (byte_offset + (int(point.point_type.len) * 2)), point.point_type.len
-                                point.value_base = point.point_type.data_to(data[byte_offset:byte_offset + (int(point.point_type.len) * 2)])
-                                if point.point_type.is_impl(point.value_base):
-                                    if point.sf_point is not None:
-                                        point.value_sf = point.sf_point.value_base
-                                else:
-                                    point.value_base = None
-                                    point.value_sf = None
-                            else:
-                                raise SunSpecClientError('No data_to function set for %s : %s' % (pname, point.point_type))
-
-            except SunSpecError, e:
-                raise SunSpecClientError(e)
-            except modbus.ModbusClientError, e:
-                raise SunSpecClientError('Modbus error: %s' % str(e))
-            except:
-                raise
-
-    def write_points(self):
-
-        addr = None
-        next_addr = None
-        data = ''
-
-        for block in self.blocks:
-            for point in block.points_list:
-                if point.dirty:
-                    point_addr = int(point.addr)
-                    point_len = int(point.point_type.len)
-                    point_data = point.point_type.to_data(point.value_base, (point_len * 2))
-                    if addr is None:
-                        addr = point_addr
-                        data = ''
-                    else:
-                        if point_addr != next_addr:
-                            block.model.device.write(addr, data)
-                            addr = point_addr
-                            data = ''
-                    next_addr = point_addr + point_len
-                    data += point_data
-                    point.dirty = False
-            if addr is not None:
-                block.model.device.write(addr, data)
-                addr = None
+	def __init__(self, dev=None, mid=None, addr=0, mlen=None, index=1):
+
+		device.Model.__init__(self, device=dev, mid=mid, addr=addr, mlen=mlen, index=index)
+
+	def load(self):
+
+		device.Model.load(self, block_class=ClientBlock, point_class=ClientPoint)
+
+	def read_points(self):
+
+		if self.model_type is not None:
+			# read current model
+			try:
+				end_index = len(self.read_blocks)
+				if end_index == 1:
+					data = self.device.read(self.addr, self.len)
+				else:
+					data = ''
+					index = 0
+					while index < end_index:
+						addr = self.read_blocks[index]
+						index += 1
+						if index < end_index:
+							read_len = self.read_blocks[index] - addr
+						else:
+							read_len = self.addr + self.len - addr
+						data += self.device.read(addr, read_len)
+				if data:
+					# print 'data len = ', len(data)
+					data_len = len(data)/2
+					if data_len != self.len:
+						raise SunSpecClientError('Error reading model %s' % self.model_type)
+
+					#  for each repeating block
+					for block in self.blocks:
+						# scale factor points
+						for pname, point in block.points_sf.iteritems():
+							offset = int(point.addr) - int(self.addr)
+							if point.point_type.data_to is not None:
+								byte_offset = offset * 2
+								# print pname, point, offset, byte_offset, (byte_offset + (int(point.point_type.len) * 2)), point.point_type.len
+								point.value_base = point.point_type.data_to(data[byte_offset:byte_offset + (int(point.point_type.len) * 2)])
+								if not point.point_type.is_impl(point.value_base):
+									point.value_base = None
+							else:
+								raise SunSpecClientError('No data_to function set for %s : %s' % (pname, point.point_type))
+
+						# non-scale factor points
+						for pname, point in block.points.iteritems():
+							offset = int(point.addr) - int(self.addr)
+							if point.point_type.data_to is not None:
+								byte_offset = offset * 2
+								# print pname, point, offset, byte_offset, (byte_offset + (int(point.point_type.len) * 2)), point.point_type.len
+								point.value_base = point.point_type.data_to(data[byte_offset:byte_offset + (int(point.point_type.len) * 2)])
+								if point.point_type.is_impl(point.value_base):
+									if point.sf_point is not None:
+										point.value_sf = point.sf_point.value_base
+								else:
+									point.value_base = None
+									point.value_sf = None
+							else:
+								raise SunSpecClientError('No data_to function set for %s : %s' % (pname, point.point_type))
+
+			except SunSpecError as e:
+				raise SunSpecClientError(e)
+			except modbus.ModbusClientError as e:
+				raise SunSpecClientError('Modbus error: %s' % str(e))
+			except:
+				raise
+
+	def write_points(self):
+
+		addr = None
+		next_addr = None
+		data = ''
+
+		for block in self.blocks:
+			for point in block.points_list:
+				if point.dirty:
+					point_addr = int(point.addr)
+					point_len = int(point.point_type.len)
+					point_data = point.point_type.to_data(point.value_base, (point_len * 2))
+					if addr is None:
+						addr = point_addr
+						data = ''
+					else:
+						if point_addr != next_addr:
+							block.model.device.write(addr, data)
+							addr = point_addr
+							data = ''
+					next_addr = point_addr + point_len
+					data += point_data
+					point.dirty = False
+			if addr is not None:
+				block.model.device.write(addr, data)
+				addr = None
 
 class ClientBlock(device.Block):
 
-    def __init__(self, model, addr, blen, block_type, index=1):
+	def __init__(self, model, addr, blen, block_type, index=1):
 
-        device.Block.__init__(self, model, addr, blen, block_type, index)
+		device.Block.__init__(self, model, addr, blen, block_type, index)
 
 class ClientPoint(device.Point):
 
-    def __init__(self, block=None, point_type=None, addr=None, sf_point=None, value=None):
+	def __init__(self, block=None, point_type=None, addr=None, sf_point=None, value=None):
 
-        device.Point.__init__(self, block, point_type, addr, sf_point, value)
+		device.Point.__init__(self, block, point_type, addr, sf_point, value)
 
-    def write(self):
+	def write(self):
 
-        data = self.point_type.to_data(self.value_base, (int(self.point_type.len) * 2))
-        self.block.model.device.write(int(self.addr), data)
-        self.dirty = False
+		data = self.point_type.to_data(self.value_base, (int(self.point_type.len) * 2))
+		self.block.model.device.write(int(self.addr), data)
+		self.dirty = False
 
 class SunSpecClientModelBase(object):
 
-    def __init__(self, model, name):
-        self.model = model
-        self.name = name
-        self.repeating = [None]
-        self.repeating_name = 'repeating'
-
-        if len(model.blocks) > 1:
-            block_class_name = self.__class__.__name__ + 'Repeating'
-            for block in model.blocks[1:]:
-                # set repeating block name and attribute if present
-                if block.block_type.name != self.repeating_name:
-                    self.repeating_name = block.block_type.name
-                    setattr(self, self.repeating_name, self.repeating)
-                # block_class_ = globals().get(block_class_name)
-                block_class = globals().get(block_class_name)
-                c = block_class(block, self.repeating_name)
-                self.repeating.append(c)
-
-    def _get_property(self, name):
-        point = self.model.points.get(name)
-        if point:
-            return point.value
-
-    def _set_property(self, name, value):
-        point = self.model.points.get(name)
-        if point:
-            point.value = value
-
-    def __getitem__(self, name):
-        return self._get_property(name)
-        # return self.__dict__.get(key, None)
-
-    def __setitem__(self, name, item):
-        return self._set_property(name, item)
-        # self.__dict__.set(key, item)
-
-    def read(self):
-        self.model.read_points()
-
-    def write(self):
-        self.model.write_points()
-
-    def __str__(self):
-        s = '\n%s (%s):\n' % (self.name, self.model.id)
-        for name in self.points:
-            value = getattr(self, name)
-            if value is not None:
-                s += '%s:  %s\n' % (name, str(value))
-
-        for block in self.repeating[1:]:
-            s += str(block)
-
-        return s
+	def __init__(self, model, name):
+		self.model = model
+		self.name = name
+		self.repeating = [None]
+		self.repeating_name = 'repeating'
+
+		if len(model.blocks) > 1:
+			block_class_name = self.__class__.__name__ + 'Repeating'
+			for block in model.blocks[1:]:
+				# set repeating block name and attribute if present
+				if block.block_type.name != self.repeating_name:
+					self.repeating_name = block.block_type.name
+					setattr(self, self.repeating_name, self.repeating)
+				# block_class_ = globals().get(block_class_name)
+				block_class = globals().get(block_class_name)
+				c = block_class(block, self.repeating_name)
+				self.repeating.append(c)
+
+	def _get_property(self, name):
+		point = self.model.points.get(name)
+		if point:
+			return point.value
+
+	def _set_property(self, name, value):
+		point = self.model.points.get(name)
+		if point:
+			point.value = value
+
+	def __getitem__(self, name):
+		return self._get_property(name)
+		# return self.__dict__.get(key, None)
+
+	def __setitem__(self, name, item):
+		return self._set_property(name, item)
+		# self.__dict__.set(key, item)
+
+	def read(self):
+		self.model.read_points()
+
+	def write(self):
+		self.model.write_points()
+
+	def __str__(self):
+		s = '\n%s (%s):\n' % (self.name, self.model.id)
+		for name in self.points:
+			value = getattr(self, name)
+			if value is not None:
+				s += '%s:  %s\n' % (name, str(value))
+
+		for block in self.repeating[1:]:
+			s += str(block)
+
+		return s
 
 class SunSpecClientBlockBase(object):
 
-    def __init__(self, block, name):
-        self.block = block
-        self.name = name
-
-    def _get_property(self, name):
-        point = self.block.points.get(name)
-        if point:
-            return point.value
-
-    def _set_property(self, name, value):
-        point = self.block.points.get(name)
-        if point:
-            point.value = value
-
-    def __getitem__(self, key):
-        return self._get_property(name)
-        # return self.__dict__.get(key, None)
-
-    def __setitem__(self, key, item):
-        return self._set_property(name, item)
-        # self.__dict__.set(key, item)
-
-    def __str__(self):
-        s = '\n%s[%d]:\n' % (self.name, self.block.index)
-        for name in self.points:
-            value = getattr(self, name)
-            if value is not None:
-                s += '%s:  %s\n' % (name, str(value))
-    
-        return s
+	def __init__(self, block, name):
+		self.block = block
+		self.name = name
+
+	def _get_property(self, name):
+		point = self.block.points.get(name)
+		if point:
+			return point.value
+
+	def _set_property(self, name, value):
+		point = self.block.points.get(name)
+		if point:
+			point.value = value
+
+	def __getitem__(self, key):
+		return self._get_property(name)
+		# return self.__dict__.get(key, None)
+
+	def __setitem__(self, key, item):
+		return self._set_property(name, item)
+		# self.__dict__.set(key, item)
+
+	def __str__(self):
+		s = '\n%s[%d]:\n' % (self.name, self.block.index)
+		for name in self.points:
+			value = getattr(self, name)
+			if value is not None:
+				s += '%s:  %s\n' % (name, str(value))
+	
+		return s
 
 def model_class_get(model_id):
 
-    def add_property(self, name, value):
-        fget = lambda self: self._get_property(name)
-        fset = lambda self, value: self._set_property(name, value)
-        setattr(self, name, property(fget, fset))
-
-    def class_init(self, model, name):
-        SunSpecClientModelBase.__init__(self, model, name)
-
-    def block_class_init(self, block, name):
-        SunSpecClientBlockBase.__init__(self, block, name)
-
-    class_name = 'Model' + str(model_id)
-    class_ = globals().get(class_name)
-    if class_ is None:
-        class_ = type(class_name, (SunSpecClientModelBase,), {'__init__' : class_init})
-        globals()[class_name] = class_
-
-    setattr(class_, 'points', [])
-    model_type = None
-    try:
-        model_type = device.model_type_get(model_id)
-    except Exception, e:
-        setattr(class_, 'load_error', str(e))
-    if model_type is not None:
-        for point_type in model_type.fixed_block.points_list:
-            if point_type.type != suns.SUNS_TYPE_SUNSSF and point_type.type != suns.SUNS_TYPE_PAD:
-                add_property(class_, point_type.id, None)
-                class_.points.append(point_type.id)
-            ### check for writable point?
-
-        block_type = model_type.repeating_block
-        if block_type is not None:
-            block_class_name = class_name + 'Repeating'
-            block_class = type(block_class_name, (SunSpecClientBlockBase,), {'__init__' : block_class_init})
-            globals()[block_class_name] = block_class
-
-            setattr(block_class, 'points', [])
-            for point_type in block_type.points_list:
-                if point_type.type != suns.SUNS_TYPE_SUNSSF and point_type.type != suns.SUNS_TYPE_PAD:
-                    add_property(block_class, point_type.id, None)
-                    block_class.points.append(point_type.id)
-
-    return class_
+	def add_property(self, name, value):
+		fget = lambda self: self._get_property(name)
+		fset = lambda self, value: self._set_property(name, value)
+		setattr(self, name, property(fget, fset))
+
+	def class_init(self, model, name):
+		SunSpecClientModelBase.__init__(self, model, name)
+
+	def block_class_init(self, block, name):
+		SunSpecClientBlockBase.__init__(self, block, name)
+
+	class_name = 'Model' + str(model_id)
+	class_ = globals().get(class_name)
+	if class_ is None:
+		class_ = type(class_name, (SunSpecClientModelBase,), {'__init__' : class_init})
+		globals()[class_name] = class_
+
+	setattr(class_, 'points', [])
+	model_type = None
+	try:
+		model_type = device.model_type_get(model_id)
+	except Exception as e:
+		setattr(class_, 'load_error', str(e))
+	if model_type is not None:
+		for point_type in model_type.fixed_block.points_list:
+			if point_type.type != suns.SUNS_TYPE_SUNSSF and point_type.type != suns.SUNS_TYPE_PAD:
+				add_property(class_, point_type.id, None)
+				class_.points.append(point_type.id)
+			### check for writable point?
+
+		block_type = model_type.repeating_block
+		if block_type is not None:
+			block_class_name = class_name + 'Repeating'
+			block_class = type(block_class_name, (SunSpecClientBlockBase,), {'__init__' : block_class_init})
+			globals()[block_class_name] = block_class
+
+			setattr(block_class, 'points', [])
+			for point_type in block_type.points_list:
+				if point_type.type != suns.SUNS_TYPE_SUNSSF and point_type.type != suns.SUNS_TYPE_PAD:
+					add_property(block_class, point_type.id, None)
+					block_class.points.append(point_type.id)
+
+	return class_
 
 class SunSpecClientDevice(object):
 
-    def __init__(self, device_type, slave_id=None, name=None, pathlist = None, baudrate=None, parity=None, ipaddr=None, ipport=None,
-                 timeout=None, trace=False, scan_progress=None, scan_delay=None):
-
-        # super(self.__class__, self).__init__(device_type, slave_id, name, pathlist, baudrate, parity, ipaddr, ipport)
-        self.device = ClientDevice(device_type, slave_id, name, pathlist, baudrate, parity, ipaddr, ipport, timeout, trace)
-        self.models = []
-
-        try:
-            # scan device models
-            self.device.scan(progress=scan_progress, delay=scan_delay)
-
-            # create named attributes for each model
-            for model in self.device.models_list:
-                model_id = str(model.id)
-                c = model_class_get(model_id)
-                if model.model_type is not None:
-                    name = model.model_type.name
-                else:
-                    name = 'model_' + model_id
-                model_class = c(model, name)
-                existing = getattr(self, name, None)
-                # if model id already defined
-                if existing:
-                    # if model id definition is not a list, turn it into a list and add existing model
-                    if type(self[name]) is not list:
-                        # model instance index starts at 1 so first first list element is None
-                        setattr(self, name, [None])
-                        self[name].append(existing)
-                    # add new model to the list
-                    self[name].append(model_class)
-                # if first model id instance, set attribute as model
-                else:
-                    setattr(self, name, model_class)
-                    self.models.append(name)
-        except Exception, e:
-            if self.device is not None:
-                self.device.close()
-            raise
-
-    def close(self):
-        self.device.close()
-
-    def read(self):
-        self.device.read_points()
-
-    def __getitem__(self, key):
-        return self.__dict__.get(key, None)
-
-    def __setitem__(self, key, item):
-        self.__dict__.set(key, item)
-        
-    def __str__(self):
-
-        s = ''
-        for model in self.models:
-            s += str(self[model])
-
-        return s
+	def __init__(self, device_type, slave_id=None, name=None, pathlist = None, baudrate=None, parity=None, ipaddr=None, ipport=None,
+				 timeout=None, trace=False, scan_progress=None, scan_delay=None):
+
+		# super(self.__class__, self).__init__(device_type, slave_id, name, pathlist, baudrate, parity, ipaddr, ipport)
+		self.device = ClientDevice(device_type, slave_id, name, pathlist, baudrate, parity, ipaddr, ipport, timeout, trace)
+		self.models = []
+
+		try:
+			# scan device models
+			self.device.scan(progress=scan_progress, delay=scan_delay)
+
+			# create named attributes for each model
+			for model in self.device.models_list:
+				model_id = str(model.id)
+				c = model_class_get(model_id)
+				if model.model_type is not None:
+					name = model.model_type.name
+				else:
+					name = 'model_' + model_id
+				model_class = c(model, name)
+				existing = getattr(self, name, None)
+				# if model id already defined
+				if existing:
+					# if model id definition is not a list, turn it into a list and add existing model
+					if type(self[name]) is not list:
+						# model instance index starts at 1 so first first list element is None
+						setattr(self, name, [None])
+						self[name].append(existing)
+					# add new model to the list
+					self[name].append(model_class)
+				# if first model id instance, set attribute as model
+				else:
+					setattr(self, name, model_class)
+					self.models.append(name)
+		except Exception as e:
+			if self.device is not None:
+				self.device.close()
+			raise
+
+	def close(self):
+		self.device.close()
+
+	def read(self):
+		self.device.read_points()
+
+	def __getitem__(self, key):
+		return self.__dict__.get(key, None)
+
+	def __setitem__(self, key, item):
+		self.__dict__.set(key, item)
+		
+	def __str__(self):
+
+		s = ''
+		for model in self.models:
+			s += str(self[model])
+
+		return s
 
 if __name__ == "__main__":
 
-    pass
+	pass
diff --git a/sunspec/core/data.py b/sunspec/core/data.py
index db76d25..8f76886 100644
--- a/sunspec/core/data.py
+++ b/sunspec/core/data.py
@@ -1,32 +1,32 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2017 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import time
 
 try:
-    import xml.etree.ElementTree as ET
+	import xml.etree.ElementTree as ET
 except:
-    import elementtree.ElementTree as ET
+	import elementtree.ElementTree as ET
 
 import sunspec.core.util as util
 
@@ -56,236 +56,236 @@ SDX_POINT_DESC = 'd'
 SDX_POINT_TIME = 't'
 
 class SunSpecDataError(Exception):
-    pass
+	pass
 
 class SunSpecData(object):
 
-    def device_add(self, logger_id=None, man=None, mod=None, sn=None, timestamp=None, cid=None, device_id=None, ifc=None, namespace=None):
+	def device_add(self, logger_id=None, man=None, mod=None, sn=None, timestamp=None, cid=None, device_id=None, ifc=None, namespace=None):
 
-    	d = DeviceData(logger_id,  man, mod, sn, timestamp, cid, device_id, ifc, namespace)
-    	self.device_data.append(d)
-    	return d
+		d = DeviceData(logger_id,  man, mod, sn, timestamp, cid, device_id, ifc, namespace)
+		self.device_data.append(d)
+		return d
 
-    def from_xml(self, element=None, data_record=None):
+	def from_xml(self, element=None, data_record=None):
 
-        if data_record is not None:
-            self.root = ET.fromstring(data_record)
-        elif element is not None:
-            self.root = element
+		if data_record is not None:
+			self.root = ET.fromstring(data_record)
+		elif element is not None:
+			self.root = element
 
-        if self.root is not None:
-            if self.root.tag != SDX_SUNSPEC_DATA:
-                raise SunSpecDataError("Unexpected root element: %s" % (self.root.tag))
+		if self.root is not None:
+			if self.root.tag != SDX_SUNSPEC_DATA:
+				raise SunSpecDataError("Unexpected root element: %s" % (self.root.tag))
 
-            self.version = self.root.attrib.get(SDX_SUNSPEC_DATA_VERSION)
+			self.version = self.root.attrib.get(SDX_SUNSPEC_DATA_VERSION)
 
-            for d in self.root.findall('*'):
-                if d.tag != SDX_DEVICE:
-                    raise SunSpecDataError("Unexpected '%s' element in '%s' element" % (d.tag, self.root.tag))
-                dd = DeviceData()
-                dd.from_xml(d)
-                self.device_data.append(dd)
+			for d in self.root.findall('*'):
+				if d.tag != SDX_DEVICE:
+					raise SunSpecDataError("Unexpected '%s' element in '%s' element" % (d.tag, self.root.tag))
+				dd = DeviceData()
+				dd.from_xml(d)
+				self.device_data.append(dd)
 
-    def to_xml(self, parent=None):
+	def to_xml(self, parent=None):
 
-        attr = {}
+		attr = {}
 
-        if self.version:
-            attr[SDX_SUNSPEC_DATA_VERSION] = self.version
+		if self.version:
+			attr[SDX_SUNSPEC_DATA_VERSION] = self.version
 
-        if parent is None:
-            self.root = ET.Element(SDX_SUNSPEC_DATA, attrib=attr)
-        else:
-            self.root = ET.SubElement(parent, SDX_SUNSPEC_DATA, attrib=attr)
+		if parent is None:
+			self.root = ET.Element(SDX_SUNSPEC_DATA, attrib=attr)
+		else:
+			self.root = ET.SubElement(parent, SDX_SUNSPEC_DATA, attrib=attr)
 
-        for d in self.device_data:
-            d.to_xml(self.root)
+		for d in self.device_data:
+			d.to_xml(self.root)
 
-    def to_xml_str(self, pretty_print=False):
+	def to_xml_str(self, pretty_print=False):
 
-        attr = {}
+		attr = {}
 
-        if self.version:
-            attr[SDX_SUNSPEC_DATA_VERSION] = self.version
+		if self.version:
+			attr[SDX_SUNSPEC_DATA_VERSION] = self.version
 
-        self.root = ET.Element(SDX_SUNSPEC_DATA, attrib=attr)
-        for d in self.device_data:
-            d.to_xml(self.root)
+		self.root = ET.Element(SDX_SUNSPEC_DATA, attrib=attr)
+		for d in self.device_data:
+			d.to_xml(self.root)
 
-        if pretty_print:
-            util.indent(self.root)
+		if pretty_print:
+			util.indent(self.root)
 
-        return ET.tostring(self.root)
+		return ET.tostring(self.root)
 
-    def __init__(self, element=None, data_record=None):
+	def __init__(self, element=None, data_record=None):
 
-        self.root = None
-        self.version = None
-        self.device_data = []
+		self.root = None
+		self.version = None
+		self.device_data = []
 
-        self.from_xml(element, data_record)
+		self.from_xml(element, data_record)
 
 class DeviceData(object):
 
-    def model_add(self, model_id=None, index=None, namespace=None):
-
-    	m = ModelData(model_id, namespace, index)
-    	self.model_data.append(m)
-    	return m
-
-    def timestamp_add(self, timestamp=None):
-
-        if timestamp is None:
-            timestamp = time.time()
-        self.timestamp = time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime(timestamp))
-
-    def from_xml(self, element):
-
-        self.logger_id = element.attrib.get(SDX_DEVICE_LOGGER_ID)
-        self.namespace = element.attrib.get(SDX_DEVICE_NAMESPACE)
-        self.device_id = element.attrib.get(SDX_DEVICE_ID)
-        self.ifc = element.attrib.get(SDX_DEVICE_IFC)
-        self.man = element.attrib.get(SDX_DEVICE_MAN)
-        self.mod = element.attrib.get(SDX_DEVICE_MOD)
-        self.sn = element.attrib.get(SDX_DEVICE_SN)
-        self.time = element.attrib.get(SDX_DEVICE_TIME)
-        self.cid = element.attrib.get(SDX_DEVICE_CORRELATION_ID)
-
-        for m in element.findall('*'):
-            if m.tag != SDX_MODEL:
-                raise SunSpecDataError("Unexpected '%s' element in '%s' element" % (m.tag, element.tag))
-            md = ModelData()
-            md.from_xml(m)
-            self.model_data.append(md)
-
-    def to_xml(self, parent):
-
-        attr = {}
-
-        if self.logger_id:
-            attr[SDX_DEVICE_LOGGER_ID] = self.logger_id
-        if self.namespace:
-            attr[SDX_DEVICE_NAMESPACE] = self.namespace
-        if self.device_id:
-            attr[SDX_DEVICE_ID] = self.device_id
-        if self.ifc:
-            attr[SDX_DEVICE_IFC] = self.ifc
-        if self.man:
-            attr[SDX_DEVICE_MAN] = self.man
-        if self.mod:
-            attr[SDX_DEVICE_MOD] = self.mod
-        if self.sn:
-            attr[SDX_DEVICE_SN] = self.sn
-        if self.timestamp:
-            attr[SDX_DEVICE_TIME] = self.timestamp
-        if self.cid:
-            attr[SDX_DEVICE_CORRELATION_ID] = self.cid
-
-        e = ET.SubElement(parent, SDX_DEVICE, attrib=attr)
-        for m in self.model_data:
-            m.to_xml(e)
-
-    def __init__(self, logger_id=None, man=None, mod=None, sn=None, timestamp=None, cid=None, device_id=None, ifc=None, namespace=None):
-
-        self.logger_id = logger_id
-        self.namespace = namespace
-        self.device_id = device_id
-        self.ifc = ifc
-        self.man = man
-        self.mod = mod
-        self.sn = sn
-        self.timestamp = timestamp
-        self.cid = cid
-        self.model_data = []
-
-        if timestamp is not None:
-            self.timestamp_add(timestamp)
+	def model_add(self, model_id=None, index=None, namespace=None):
+
+		m = ModelData(model_id, namespace, index)
+		self.model_data.append(m)
+		return m
+
+	def timestamp_add(self, timestamp=None):
+
+		if timestamp is None:
+			timestamp = time.time()
+		self.timestamp = time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime(timestamp))
+
+	def from_xml(self, element):
+
+		self.logger_id = element.attrib.get(SDX_DEVICE_LOGGER_ID)
+		self.namespace = element.attrib.get(SDX_DEVICE_NAMESPACE)
+		self.device_id = element.attrib.get(SDX_DEVICE_ID)
+		self.ifc = element.attrib.get(SDX_DEVICE_IFC)
+		self.man = element.attrib.get(SDX_DEVICE_MAN)
+		self.mod = element.attrib.get(SDX_DEVICE_MOD)
+		self.sn = element.attrib.get(SDX_DEVICE_SN)
+		self.time = element.attrib.get(SDX_DEVICE_TIME)
+		self.cid = element.attrib.get(SDX_DEVICE_CORRELATION_ID)
+
+		for m in element.findall('*'):
+			if m.tag != SDX_MODEL:
+				raise SunSpecDataError("Unexpected '%s' element in '%s' element" % (m.tag, element.tag))
+			md = ModelData()
+			md.from_xml(m)
+			self.model_data.append(md)
+
+	def to_xml(self, parent):
+
+		attr = {}
+
+		if self.logger_id:
+			attr[SDX_DEVICE_LOGGER_ID] = self.logger_id
+		if self.namespace:
+			attr[SDX_DEVICE_NAMESPACE] = self.namespace
+		if self.device_id:
+			attr[SDX_DEVICE_ID] = self.device_id
+		if self.ifc:
+			attr[SDX_DEVICE_IFC] = self.ifc
+		if self.man:
+			attr[SDX_DEVICE_MAN] = self.man
+		if self.mod:
+			attr[SDX_DEVICE_MOD] = self.mod
+		if self.sn:
+			attr[SDX_DEVICE_SN] = self.sn
+		if self.timestamp:
+			attr[SDX_DEVICE_TIME] = self.timestamp
+		if self.cid:
+			attr[SDX_DEVICE_CORRELATION_ID] = self.cid
+
+		e = ET.SubElement(parent, SDX_DEVICE, attrib=attr)
+		for m in self.model_data:
+			m.to_xml(e)
+
+	def __init__(self, logger_id=None, man=None, mod=None, sn=None, timestamp=None, cid=None, device_id=None, ifc=None, namespace=None):
+
+		self.logger_id = logger_id
+		self.namespace = namespace
+		self.device_id = device_id
+		self.ifc = ifc
+		self.man = man
+		self.mod = mod
+		self.sn = sn
+		self.timestamp = timestamp
+		self.cid = cid
+		self.model_data = []
+
+		if timestamp is not None:
+			self.timestamp_add(timestamp)
 
 class ModelData(object):
 
-    def __init__(self, model_id=None, index=None, namespace=None):
+	def __init__(self, model_id=None, index=None, namespace=None):
 
-        self.model_id = str(model_id)
-        self.namespace = namespace
-        self.index = index
-        self.point_data = []
+		self.model_id = str(model_id)
+		self.namespace = namespace
+		self.index = index
+		self.point_data = []
 
-    def point_add(self, point_id=None, value=None, index=None, sf=None, units=None, desc=None, time=None):
+	def point_add(self, point_id=None, value=None, index=None, sf=None, units=None, desc=None, time=None):
 
-    	p = PointData(point_id, value, index, sf, units, desc, time)
-    	self.point_data.append(p)
-    	return p
+		p = PointData(point_id, value, index, sf, units, desc, time)
+		self.point_data.append(p)
+		return p
 
-    def from_xml(self, element):
+	def from_xml(self, element):
 
-        self.model_id = element.attrib.get(SDX_MODEL_ID)
-        self.namespace = element.attrib.get(SDX_MODEL_NAMESPACE)
-        index = element.attrib.get(SDX_MODEL_INDEX)
-        if index is not None:
-            index = int(index)
-        self.index = index
-        for p in element.findall('*'):
-            if p.tag != SDX_POINT:
-                raise SunSpecDataError("Unexpected '%s' element in '%s' element" % (p.tag, element.tag))
-            pd = PointData()
-            pd.from_xml(p)
-            self.point_data.append(pd)
+		self.model_id = element.attrib.get(SDX_MODEL_ID)
+		self.namespace = element.attrib.get(SDX_MODEL_NAMESPACE)
+		index = element.attrib.get(SDX_MODEL_INDEX)
+		if index is not None:
+			index = int(index)
+		self.index = index
+		for p in element.findall('*'):
+			if p.tag != SDX_POINT:
+				raise SunSpecDataError("Unexpected '%s' element in '%s' element" % (p.tag, element.tag))
+			pd = PointData()
+			pd.from_xml(p)
+			self.point_data.append(pd)
 
-    def to_xml(self, parent):
+	def to_xml(self, parent):
 
-        attr = {SDX_MODEL_ID: str(self.model_id)}
+		attr = {SDX_MODEL_ID: str(self.model_id)}
 
-        if self.index > 1:
-            attr[SDX_MODEL_INDEX] = self.index
-        if self.namespace:
-            attr[SDX_MODEL_NAMESPACE] = self.namespace
+		if self.index > 1:
+			attr[SDX_MODEL_INDEX] = self.index
+		if self.namespace:
+			attr[SDX_MODEL_NAMESPACE] = self.namespace
 
-        e = ET.SubElement(parent, SDX_MODEL, attrib=attr)
-        for p in self.point_data:
-            p.to_xml(e)
+		e = ET.SubElement(parent, SDX_MODEL, attrib=attr)
+		for p in self.point_data:
+			p.to_xml(e)
 
 class PointData(object):
 
-    def __init__(self, point_id=None, value=None, index=None, sf=None, units=None, desc=None, time=None):
-
-        self.point_id = point_id
-        self.value = value
-        self.index = index
-        self.sf = sf
-        self.units = units
-        self.desc = desc
-        self.time = time
-
-    # skip units and description for now
-    def from_xml(self, element):
-
-        self.point_id = element.attrib.get(SDX_POINT_ID)
-        index = element.attrib.get(SDX_POINT_INDEX)
-        if index is not None:
-            index = int(index)
-        self.index = index
-        sf = element.attrib.get(SDX_POINT_SF)
-        if sf is not None:
-            sf = int(sf)
-        self.sf = sf
-        # self.units = element.attrib.get(SDX_POINT_UNITS)
-        # self.desc = element.attrib.get(SDX_POINT_DESC)
-        self.time = element.attrib.get(SDX_POINT_TIME)
-        self.value = element.text
-
-    def to_xml(self, parent):
-
-        attr = {SDX_POINT_ID: str(self.point_id)}
-
-        if self.index:
-            attr[SDX_POINT_INDEX] = str(self.index)
-        if self.sf is not None:
-            attr[SDX_POINT_SF] = str(self.sf)
-        if self.time:
-            attr[SDX_POINT_TIME] = self.time
-
-        e = ET.SubElement(parent, SDX_POINT, attrib=attr)
-        if self.value is not None:
-            e.text = str(self.value)
+	def __init__(self, point_id=None, value=None, index=None, sf=None, units=None, desc=None, time=None):
+
+		self.point_id = point_id
+		self.value = value
+		self.index = index
+		self.sf = sf
+		self.units = units
+		self.desc = desc
+		self.time = time
+
+	# skip units and description for now
+	def from_xml(self, element):
+
+		self.point_id = element.attrib.get(SDX_POINT_ID)
+		index = element.attrib.get(SDX_POINT_INDEX)
+		if index is not None:
+			index = int(index)
+		self.index = index
+		sf = element.attrib.get(SDX_POINT_SF)
+		if sf is not None:
+			sf = int(sf)
+		self.sf = sf
+		# self.units = element.attrib.get(SDX_POINT_UNITS)
+		# self.desc = element.attrib.get(SDX_POINT_DESC)
+		self.time = element.attrib.get(SDX_POINT_TIME)
+		self.value = element.text
+
+	def to_xml(self, parent):
+
+		attr = {SDX_POINT_ID: str(self.point_id)}
+
+		if self.index:
+			attr[SDX_POINT_INDEX] = str(self.index)
+		if self.sf is not None:
+			attr[SDX_POINT_SF] = str(self.sf)
+		if self.time:
+			attr[SDX_POINT_TIME] = self.time
+
+		e = ET.SubElement(parent, SDX_POINT, attrib=attr)
+		if self.value is not None:
+			e.text = str(self.value)
 
 
diff --git a/sunspec/core/device.py b/sunspec/core/device.py
index 0643262..5c9a1f9 100644
--- a/sunspec/core/device.py
+++ b/sunspec/core/device.py
@@ -1,33 +1,33 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2017 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import os
 import math
 
 try:
-    import xml.etree.ElementTree as ET
+	import xml.etree.ElementTree as ET
 except:
-    import elementtree.ElementTree as ET
+	import elementtree.ElementTree as ET
 
 import sunspec.core.pics as pics
 import sunspec.core.smdx as smdx
@@ -41,487 +41,487 @@ MAX_READ_COUNT = 125
 
 class Device(object):
 
-    def __init__(self, addr=suns.SUNS_BASE_ADDR_DEFAULT):
-
-        self.base_addr = addr
-        self.models_list = []
-        self.models = {}               # dict of model arrays to support more than one instance of a model
-
-    def add_model(self, model):
-
-        models = self.models.get(model.id)
-        if models is None:
-            self.models[model.id] = []
-            models = self.models.get(model.id)
-        models.append(model)
-        self.models_list.append(model)
-
-    def from_pics(self, element=None, filename=None, pathlist=None):
-
-        global file_pathlist
-
-        pics_data = ''
-
-        try:
-            if element is None:
-                # try supplied path list
-                if pathlist is not None:
-                    try:
-                        pics_data = pathlist.read(filename)
-                    except NameError:
-                        pass
-
-                # try device file path list
-                if not pics_data and file_pathlist is not None:
-                    try:
-                        pics_data = file_pathlist.read(filename)
-                    except NameError:
-                        pass
-
-                # try local directory
-                if not pics_data:
-                    f = open(filename, 'r')
-                    pics_data = f.read()
-                    f.close()
-
-                root = ET.fromstring(pics_data)
-                if root.tag != pics.PICS_ROOT:
-                    raise SunSpecError("Unexpected root element: %s" % (root.tag))
-
-                d = root.find(pics.PICS_DEVICE)
-                if d is None:
-                    raise SunSpecError("No '%s' elements found in '%s' element" % (pics.PICS_DEVICE, root.tag))
-            else:
-                d = element
-            if d.tag != pics.PICS_DEVICE:
-                raise SunSpecError("Unexpected device tag: '%s'" % (d.tag))
-            self.base_addr = d.attrib.get(pics.PICS_ATTR_BASE_ADDR, pics.PICS_BASE_ADDR_DEFAULT)
-            addr = self.base_addr + 2
-
-            for m in d.findall('*'):
-                if m is None:
-                    raise SunSpecError("No '%s' elements found in '%s' element" % (pics.PICS_MODEL, d.tag))
-                if m.tag != pics.PICS_MODEL:
-                    raise SunSpecError("Unexpected '%s' element in '%s' element" % (m.tag, d.tag))
-
-                model_id = m.attrib.get(pics.PICS_ATTR_ID)
-                if model_id is None:
-                    raise SunSpecError('Module id error')
-                model_len = m.attrib.get(pics.PICS_ATTR_LEN)
-                if model_len is not None:
-                    # raise SunSpecError('Module len error in model %d' % (model_id))
-                    model_len = int(model_len)
-
-                # move address past model id and length (even though address is not real in the case)
-                model = Model(self, model_id, addr + 2, model_len)
-                try:
-                    model.load()
-                except Exception, e:
-                    model.load_error = str(e)
-                model.from_pics(m)
-                self.add_model(model)
-
-                addr += model.len + 2
-        
-        except Exception, e:
-            raise SunSpecError('Error loading PICS: %s' % str(e))
-
-    """
-    def to_pics(self, pretty_print=False, single_repeating=True):
-
-        attr = {pics.PICS_ATTR_VERSION: str(pics.PICS_VERSION)}
-
-        root = ET.Element(pics.PICS_ROOT)
-        e = ET.SubElement(root, pics.PICS_DEVICE, attrib=attr)
-
-        for model in self.models_list:
-            model.to_pics(e, single_repeating=single_repeating)
-
-        if pretty_print:
-            util.indent(root)
-
-        return ET.tostring(root)
-    """
-
-    def to_pics(self, parent, single_repeating=True):
-
-        attr = {pics.PICS_ATTR_VERSION: str(pics.PICS_VERSION)}
-
-        e = ET.SubElement(parent, pics.PICS_DEVICE, attrib=attr)
-
-        for model in self.models_list:
-            model.to_pics(e, single_repeating=single_repeating)
-
-    def not_equal(self, device):
-
-        if len(self.models_list) != len(device.models_list):
-            return 'Devices not equal - model counts: %d  %d' % (len(self.models_list), len(device.models_list))
-        for i in range(len(self.models_list)):
-            s = self.models_list[i].not_equal(device.models_list[i])
-            if s:
-                return 'Devices not equal - %s' % (s)
-        return False
-
-    def __str__(self):
-
-        device_str = ''
-        for model in self.models_list:
-            device_str += str(model)
-        return device_str
+	def __init__(self, addr=suns.SUNS_BASE_ADDR_DEFAULT):
+
+		self.base_addr = addr
+		self.models_list = []
+		self.models = {}			   # dict of model arrays to support more than one instance of a model
+
+	def add_model(self, model):
+
+		models = self.models.get(model.id)
+		if models is None:
+			self.models[model.id] = []
+			models = self.models.get(model.id)
+		models.append(model)
+		self.models_list.append(model)
+
+	def from_pics(self, element=None, filename=None, pathlist=None):
+
+		global file_pathlist
+
+		pics_data = ''
+
+		try:
+			if element is None:
+				# try supplied path list
+				if pathlist is not None:
+					try:
+						pics_data = pathlist.read(filename)
+					except NameError:
+						pass
+
+				# try device file path list
+				if not pics_data and file_pathlist is not None:
+					try:
+						pics_data = file_pathlist.read(filename)
+					except NameError:
+						pass
+
+				# try local directory
+				if not pics_data:
+					f = open(filename, 'r')
+					pics_data = f.read()
+					f.close()
+
+				root = ET.fromstring(pics_data)
+				if root.tag != pics.PICS_ROOT:
+					raise SunSpecError("Unexpected root element: %s" % (root.tag))
+
+				d = root.find(pics.PICS_DEVICE)
+				if d is None:
+					raise SunSpecError("No '%s' elements found in '%s' element" % (pics.PICS_DEVICE, root.tag))
+			else:
+				d = element
+			if d.tag != pics.PICS_DEVICE:
+				raise SunSpecError("Unexpected device tag: '%s'" % (d.tag))
+			self.base_addr = d.attrib.get(pics.PICS_ATTR_BASE_ADDR, pics.PICS_BASE_ADDR_DEFAULT)
+			addr = self.base_addr + 2
+
+			for m in d.findall('*'):
+				if m is None:
+					raise SunSpecError("No '%s' elements found in '%s' element" % (pics.PICS_MODEL, d.tag))
+				if m.tag != pics.PICS_MODEL:
+					raise SunSpecError("Unexpected '%s' element in '%s' element" % (m.tag, d.tag))
+
+				model_id = m.attrib.get(pics.PICS_ATTR_ID)
+				if model_id is None:
+					raise SunSpecError('Module id error')
+				model_len = m.attrib.get(pics.PICS_ATTR_LEN)
+				if model_len is not None:
+					# raise SunSpecError('Module len error in model %d' % (model_id))
+					model_len = int(model_len)
+
+				# move address past model id and length (even though address is not real in the case)
+				model = Model(self, model_id, addr + 2, model_len)
+				try:
+					model.load()
+				except Exception as e:
+					model.load_error = str(e)
+				model.from_pics(m)
+				self.add_model(model)
+
+				addr += model.len + 2
+		
+		except Exception as e:
+			raise SunSpecError('Error loading PICS: %s' % str(e))
+
+	"""
+	def to_pics(self, pretty_print=False, single_repeating=True):
+
+		attr = {pics.PICS_ATTR_VERSION: str(pics.PICS_VERSION)}
+
+		root = ET.Element(pics.PICS_ROOT)
+		e = ET.SubElement(root, pics.PICS_DEVICE, attrib=attr)
+
+		for model in self.models_list:
+			model.to_pics(e, single_repeating=single_repeating)
+
+		if pretty_print:
+			util.indent(root)
+
+		return ET.tostring(root)
+	"""
+
+	def to_pics(self, parent, single_repeating=True):
+
+		attr = {pics.PICS_ATTR_VERSION: str(pics.PICS_VERSION)}
+
+		e = ET.SubElement(parent, pics.PICS_DEVICE, attrib=attr)
+
+		for model in self.models_list:
+			model.to_pics(e, single_repeating=single_repeating)
+
+	def not_equal(self, device):
+
+		if len(self.models_list) != len(device.models_list):
+			return 'Devices not equal - model counts: %d  %d' % (len(self.models_list), len(device.models_list))
+		for i in range(len(self.models_list)):
+			s = self.models_list[i].not_equal(device.models_list[i])
+			if s:
+				return 'Devices not equal - %s' % (s)
+		return False
+
+	def __str__(self):
+
+		device_str = ''
+		for model in self.models_list:
+			device_str += str(model)
+		return device_str
 
 class Block(object):
 
-    def __init__(self, model, addr, blen, block_type, index=1):
+	def __init__(self, model, addr, blen, block_type, index=1):
 
-        self.model = model
-        self.block_type = block_type
-        self.addr = addr
-        self.len = blen
-        self.type = block_type.type
-        self.index = index
-        self.points_list = []
-        self.points = {}
-        self.points_sf = {}
+		self.model = model
+		self.block_type = block_type
+		self.addr = addr
+		self.len = blen
+		self.type = block_type.type
+		self.index = index
+		self.points_list = []
+		self.points = {}
+		self.points_sf = {}
 
-    def from_pics(self, element):
+	def from_pics(self, element):
 
-        for p in element.findall('*'):
-            if p.tag != pics.PICS_POINT:
-                raise SunSpecError("Unexpected '%s' element in '%s' element" % (p.tag, element.tag))
-            pid = p.attrib.get(pics.PICS_ATTR_ID)
-            point = self.points.get(pid)
-            if point is None:
-                point = self.points_sf.get(pid)
-            if point is not None:
-                point.from_pics(p)
+		for p in element.findall('*'):
+			if p.tag != pics.PICS_POINT:
+				raise SunSpecError("Unexpected '%s' element in '%s' element" % (p.tag, element.tag))
+			pid = p.attrib.get(pics.PICS_ATTR_ID)
+			point = self.points.get(pid)
+			if point is None:
+				point = self.points_sf.get(pid)
+			if point is not None:
+				point.from_pics(p)
 
-        # resolve scale factor values in points, must be done after all points in block are read
-        for point in self.points_list:
-            if point.sf_point is not None:
-                point.value_sf = point.sf_point.value_base
+		# resolve scale factor values in points, must be done after all points in block are read
+		for point in self.points_list:
+			if point.sf_point is not None:
+				point.value_sf = point.sf_point.value_base
 
-    def to_pics(self, parent):
+	def to_pics(self, parent):
 
-        attr = {}
+		attr = {}
 
-        if self.index > 1:
-            attr[pics.PICS_ATTR_INDEX] = str(self.index)
+		if self.index > 1:
+			attr[pics.PICS_ATTR_INDEX] = str(self.index)
 
-        if self.block_type.type == suns.SUNS_BLOCK_REPEATING:
-            attr[pics.PICS_ATTR_TYPE] = pics.PICS_TYPE_REPEATING
+		if self.block_type.type == suns.SUNS_BLOCK_REPEATING:
+			attr[pics.PICS_ATTR_TYPE] = pics.PICS_TYPE_REPEATING
 
-        e = ET.SubElement(parent, pics.PICS_BLOCK, attrib=attr)
+		e = ET.SubElement(parent, pics.PICS_BLOCK, attrib=attr)
 
-        # use block type points list to preserve original order of points in the block
-        for pt in self.block_type.points_list:
-            point = self.points.get(pt.id)
-            if point is None:
-                point = self.points_sf.get(pt.id)
-            if point is not None:
-                point.to_pics(e)
+		# use block type points list to preserve original order of points in the block
+		for pt in self.block_type.points_list:
+			point = self.points.get(pt.id)
+			if point is None:
+				point = self.points_sf.get(pt.id)
+			if point is not None:
+				point.to_pics(e)
 
-    def not_equal(self, block):
+	def not_equal(self, block):
 
-        s = self.block_type.not_equal(block.block_type)
-        if s:
-            return 'block %s not equal - block type not equal: %s' % (self.block_type.type, s)
+		s = self.block_type.not_equal(block.block_type)
+		if s:
+			return 'block %s not equal - block type not equal: %s' % (self.block_type.type, s)
 
-        for point in self.points_list:
-            s = point.not_equal(block.points.get(point.point_type.id))
-            if s:
-                return 'block %d not equal - %s' % (self.index, s)
-        return False
+		for point in self.points_list:
+			s = point.not_equal(block.points.get(point.point_type.id))
+			if s:
+				return 'block %d not equal - %s' % (self.index, s)
+		return False
 
-    def __str__(self):
+	def __str__(self):
 
-        block_str = 'Block: type: %s index: %d:\n' % (self.type, self.index)
-        for point in self.points_list:
-            block_str += '  ' + str(point) + '\n'
-        return block_str
+		block_str = 'Block: type: %s index: %d:\n' % (self.type, self.index)
+		for point in self.points_list:
+			block_str += '  ' + str(point) + '\n'
+		return block_str
 
 class Point(object):
 
-    def __init__(self, block=None, point_type=None, addr=None, sf_point=None, value=None):
-
-        self.block = block
-        self.point_type = point_type
-        self.addr = addr
-        self.sf_point = sf_point
-        self.impl = True
-        self.value_base = value
-        self.value_sf = None
-        self.dirty = False
-
-    """ 
-    @property
-    def value(self):
-        if self.value_sf:
-            return self.value_base * math.pow(10, self.value_sf)
-        else:
-            return self.value_base
-
-    @value.setter
-    def value(self, v):
-        if self.value_sf:
-            self.value_base = int(round(float(v), abs(self.value_sf)) / math.pow(10, self.value_sf))
-        else:
-            self.value_base = v
-        self.dirty = True
-
-    @property
-    def value_str(self):
-        if self.value_sf:
-            pass
-        else:
-            return str(self.value_base)
-
-    @value.setter
-    def value_str(self, v):
-        if self.value_sf:
-            pass
-        else:
-            self.value_base = int(v)
-    """
-
-    # use older property format to support earlier python 2.x versions
-    def value_getter(self):
-
-        if self.value_sf:
-            return self.value_base * math.pow(10, self.value_sf)
-        else:
-            return self.value_base
-
-    def value_setter(self, v):
-
-        if self.value_sf:
-            self.value_base = int(round(float(v), abs(self.value_sf)) / math.pow(10, self.value_sf))
-        else:
-            self.value_base = self.point_type.to_value(v)
-
-        self.dirty = True
-    
-    value = property(value_getter, value_setter, None)
-
-    def from_pics(self, element):
-
-        impl = True
-        impl_attr = element.attrib.get(pics.PICS_ATTR_IMPLEMENTED)
-        if impl_attr:
-            if impl_attr == pics.PICS_IMPLEMENTED_FALSE:
-                impl = False
-
-        value = None
-        if impl:
-            if element.text:
-                value = self.point_type.to_value(element.text)
-                self.impl = self.point_type.is_impl(value)
-        else:
-            self.impl = False
-
-        if self.impl and value is not None:
-            self.value_base = value
-
-    def to_pics(self, parent):
-
-        attr = {pics.PICS_ATTR_ID: str(self.point_type.id)}
-
-        if self.value is None:
-            attr[pics.PICS_ATTR_IMPLEMENTED] = str(pics.PICS_IMPLEMENTED_FALSE)
-        else:
-            if self.point_type.access != suns.SUNS_ACCESS_R:
-                access =  [key for key, value in pics.pics_access_types.iteritems() if value == suns.SUNS_ACCESS_RW][0]
-                attr[pics.PICS_ATTR_ACCESS] = str(access)
-
-        e = ET.SubElement(parent, pics.PICS_POINT, attrib=attr)
-        if self.value_base is not None:
-            e.text = str(self.value_base).rstrip('\0')
-
-    def not_equal(self, point):
-
-        s = self.point_type.not_equal(point.point_type)
-        if s:
-            return 'point %s not equal - point type not equal: %s' % (self.point_type.id, s)
-
-        if (((self.value_base is not None or point.value_base is not None) and (self.value_base != point.value_base)) or
-            ((self.value_sf is not None or point.value_sf is not None) and (self.value_sf != point.value_sf))):
-            if self.value_base is not None:
-                print 'self.value_base'
-            if point.value_base is not None:
-                print 'point.value_base', type(point.value_base), point.value_base
-            return 'point %s not equal: %s %s - %s %s' % (self.point_type.id, self.value_base, self.value_sf, point.value_base, point.value_sf)
-        return False
-        
-    def __str__(self):
-        point_str = 'Point: id = %s impl= %s addr = %s value_base = %s' % (self.point_type.id, str(self.impl), self.addr, str(self.value_base))
-        if self.sf_point is not None:
-            point_str += ' sf_value = %s' % (str(self.sf_point.value_base))
-        return point_str
+	def __init__(self, block=None, point_type=None, addr=None, sf_point=None, value=None):
+
+		self.block = block
+		self.point_type = point_type
+		self.addr = addr
+		self.sf_point = sf_point
+		self.impl = True
+		self.value_base = value
+		self.value_sf = None
+		self.dirty = False
+
+	""" 
+	@property
+	def value(self):
+		if self.value_sf:
+			return self.value_base * math.pow(10, self.value_sf)
+		else:
+			return self.value_base
+
+	@value.setter
+	def value(self, v):
+		if self.value_sf:
+			self.value_base = int(round(float(v), abs(self.value_sf)) / math.pow(10, self.value_sf))
+		else:
+			self.value_base = v
+		self.dirty = True
+
+	@property
+	def value_str(self):
+		if self.value_sf:
+			pass
+		else:
+			return str(self.value_base)
+
+	@value.setter
+	def value_str(self, v):
+		if self.value_sf:
+			pass
+		else:
+			self.value_base = int(v)
+	"""
+
+	# use older property format to support earlier python 2.x versions
+	def value_getter(self):
+
+		if self.value_sf:
+			return self.value_base * math.pow(10, self.value_sf)
+		else:
+			return self.value_base
+
+	def value_setter(self, v):
+
+		if self.value_sf:
+			self.value_base = int(round(float(v), abs(self.value_sf)) / math.pow(10, self.value_sf))
+		else:
+			self.value_base = self.point_type.to_value(v)
+
+		self.dirty = True
+	
+	value = property(value_getter, value_setter, None)
+
+	def from_pics(self, element):
+
+		impl = True
+		impl_attr = element.attrib.get(pics.PICS_ATTR_IMPLEMENTED)
+		if impl_attr:
+			if impl_attr == pics.PICS_IMPLEMENTED_FALSE:
+				impl = False
+
+		value = None
+		if impl:
+			if element.text:
+				value = self.point_type.to_value(element.text)
+				self.impl = self.point_type.is_impl(value)
+		else:
+			self.impl = False
+
+		if self.impl and value is not None:
+			self.value_base = value
+
+	def to_pics(self, parent):
+
+		attr = {pics.PICS_ATTR_ID: str(self.point_type.id)}
+
+		if self.value is None:
+			attr[pics.PICS_ATTR_IMPLEMENTED] = str(pics.PICS_IMPLEMENTED_FALSE)
+		else:
+			if self.point_type.access != suns.SUNS_ACCESS_R:
+				access =  [key for key, value in pics.pics_access_types.iteritems() if value == suns.SUNS_ACCESS_RW][0]
+				attr[pics.PICS_ATTR_ACCESS] = str(access)
+
+		e = ET.SubElement(parent, pics.PICS_POINT, attrib=attr)
+		if self.value_base is not None:
+			e.text = str(self.value_base).rstrip('\0')
+
+	def not_equal(self, point):
+
+		s = self.point_type.not_equal(point.point_type)
+		if s:
+			return 'point %s not equal - point type not equal: %s' % (self.point_type.id, s)
+
+		if (((self.value_base is not None or point.value_base is not None) and (self.value_base != point.value_base)) or
+			((self.value_sf is not None or point.value_sf is not None) and (self.value_sf != point.value_sf))):
+			if self.value_base is not None:
+				print('self.value_base')
+			if point.value_base is not None:
+				print('point.value_base', type(point.value_base), point.value_base)
+			return 'point %s not equal: %s %s - %s %s' % (self.point_type.id, self.value_base, self.value_sf, point.value_base, point.value_sf)
+		return False
+		
+	def __str__(self):
+		point_str = 'Point: id = %s impl= %s addr = %s value_base = %s' % (self.point_type.id, str(self.impl), self.addr, str(self.value_base))
+		if self.sf_point is not None:
+			point_str += ' sf_value = %s' % (str(self.sf_point.value_base))
+		return point_str
 
 class ScaleFactor(object):
 
-    def __init__(self, value=None):
+	def __init__(self, value=None):
 
-        self.value_base = value
+		self.value_base = value
 
 class Model(object):
 
-    def __init__(self, device=None, mid=None, addr=0, mlen=0, index=1):
-
-        self.device = device
-        self.id = int(mid)
-        self.index = index
-        self.model_type = None
-        self.addr = addr               # modbus address of first point in the model
-        self.len = int(mlen)           # register count of the point elements in the model
-        self.points_list = []          # fixed block non-scale factor points list ordered by offset
-        self.points = {}               # fixed block non-scale factor points
-        self.points_sf = {}            # fixed block scale factor points
-        self.blocks = []
-        self.load_error = None
-        self.read_blocks = []
-
-    def load(self, block_class=Block, point_class=Point):
-
-        last_read_addr = self.addr
-        self.read_blocks.append(last_read_addr)
-
-        self.model_type = model_type_get(self.id)
-
-        if self.model_type is not None:
-            if self.len == 0:
-                self.len = self.model_type.len
-            end_addr = self.addr + self.len
-
-            index = 0
-            # model type always has a fixed block defined
-            block_type = self.model_type.fixed_block
-            block_addr = self.addr
-            block_len = int(block_type.len)
-            # adjustment for legacy common model len = 65
-            if self.id == 1 and self.len == 65:
-                block_len = self.len
-
-            # while another block
-            while end_addr >= block_addr + block_len:
-                block = block_class(self, block_addr, block_len, block_type, index)
-                self.blocks.append(block)
-
-                for point_type in block_type.points_list:
-                    if point_type.type != suns.SUNS_TYPE_PAD:
-                        point_addr = int(block_addr) + int(point_type.offset)
-                        point = point_class(block, point_type, str(point_addr))
-                        if point_addr + point.point_type.len - last_read_addr > MAX_READ_COUNT:
-                            last_read_addr = point_addr
-                            self.read_blocks.append(last_read_addr)
-                        if point_type.type == suns.SUNS_TYPE_SUNSSF:
-                            block.points_sf[point_type.id] = point
-                        else:
-                            block.points_list.append(point)
-                            block.points[point_type.id] = point
-
-                # resolve scale factor addresses for repeating block
-                for point in block.points_list:
-                    if point.point_type.sf is not None and point.sf_point is None:
-                        # check for constant scale factor
-                        try:
-                            sf_value = int(point.point_type.sf)
-                            point.sf_point = ScaleFactor(sf_value)
-                        except Exception:
-                            pass
-                        # try local repeating block first
-                        if point.sf_point is None:
-                            point.sf_point = block.points_sf.get(point.point_type.sf)
-                        if point.sf_point is None:
-                            # if repeating block, try fixed block
-                            if index > 0:
-                                point.sf_point = self.blocks[0].points_sf.get(point.point_type.sf)
-                        if point.sf_point is None:
-                            # ### what state should model be left in on exception
-                            raise SunSpecError('Unable to resolve scale factor point %s for point %s in model %s' %
-                                point.point_type.sf, point.point_type.pid, self.id)
-
-                block_addr += block_len
-                block_type = self.model_type.repeating_block
-                if block_type is None:
-                    ### check for extra registers?
-                    break
-                index += 1
-                block_len = int(block_type.len)
-        else:
-            raise SunSpecError('Unknown model type - id: %s' % str(self.id))
-
-        # expose fixed block points at model level if present
-        try:
-            self.points_list = self.blocks[0].points_list
-            self.points = self.blocks[0].points
-            self.points_sf = self.blocks[0].points_sf
-        except IndexError:
-            pass
-
-    def from_pics(self, element):
-
-        # update index if present
-        self.index = element.attrib.get(pics.PICS_ATTR_INDEX, self.index)
-
-        for b in element.findall('*'):
-            if b.tag != pics.PICS_BLOCK:
-                raise SunSpecError("Unexpected '%s' element in '%s' element" % (b.tag, element.tag))
-            block_type = pics.pics_block_types.get(b.attrib.get(pics.PICS_ATTR_TYPE, pics.PICS_TYPE_FIXED))
-            if block_type is None:
-                raise SunSpecError('Unknown block type')
-            if block_type == suns.SUNS_BLOCK_FIXED:
-                if len(self.blocks) > 0:
-                    self.blocks[0].from_pics(b)
-            elif block_type == suns.SUNS_BLOCK_REPEATING:
-                block_index = b.attrib.get(pics.PICS_ATTR_INDEX)
-                # if no index specified, apply to all repeating blocks
-                if block_index is None:
-                    if len(self.blocks) > 1:
-                        for block in self.blocks[1:]:
-                            block.from_pics(b)
-                else:
-                    block_index = int(block_index)
-                    if len(self.blocks) < block_index:
-                        raise SunSpecError('Block index out of range: %s' % (str(block_index)))
-                    self.blocks[block_index].from_pics(b)
-            else:
-                raise SunSpecError('Internal block type error')
-
-    def to_pics(self, parent, single_repeating=True):
-
-        attr = {pics.PICS_ATTR_ID: str(self.id), pics.PICS_ATTR_LEN: str(self.len)}
-
-        if self.index != 1:
-            attr[pics.PICS_ATTR_INDEX] = str(self.index)
-
-        e = ET.SubElement(parent, pics.PICS_MODEL, attrib=attr)
-
-        for block in self.blocks:
-            if single_repeating == False or block.index <= 1:
-                block.to_pics(e)
-
-    def not_equal(self, model):
-
-        if len(self.blocks) != len(model.blocks):
-            return 'model %s not equal - block counts: %d  %d' % (self.model_type.id, len(self.blocks), len(model.blocks))
-        s = self.model_type.not_equal(model.model_type)
-        if s:
-            return 'model %s not equal - model id not equal: %s' % (self.model_type.id, s)
-
-        for i in range(len(self.blocks)):
-            s = self.blocks[i].not_equal(model.blocks[i])
-            if s:
-                return 'model %s not equal - %s' % (self.model_type.id, s)
-        return False
-
-    def __str__(self):
-
-        model_str = 'Model %s:\n' % self.id
-        for point in self.points_list:
-            model_str += '  ' + str(point) + '\n'
-        for block in self.blocks[1:]:
-            model_str += str(block)
-        return model_str
+	def __init__(self, device=None, mid=None, addr=0, mlen=0, index=1):
+
+		self.device = device
+		self.id = int(mid)
+		self.index = index
+		self.model_type = None
+		self.addr = addr			   # modbus address of first point in the model
+		self.len = int(mlen)		   # register count of the point elements in the model
+		self.points_list = []		  # fixed block non-scale factor points list ordered by offset
+		self.points = {}			   # fixed block non-scale factor points
+		self.points_sf = {}			# fixed block scale factor points
+		self.blocks = []
+		self.load_error = None
+		self.read_blocks = []
+
+	def load(self, block_class=Block, point_class=Point):
+
+		last_read_addr = self.addr
+		self.read_blocks.append(last_read_addr)
+
+		self.model_type = model_type_get(self.id)
+
+		if self.model_type is not None:
+			if self.len == 0:
+				self.len = self.model_type.len
+			end_addr = self.addr + self.len
+
+			index = 0
+			# model type always has a fixed block defined
+			block_type = self.model_type.fixed_block
+			block_addr = self.addr
+			block_len = int(block_type.len)
+			# adjustment for legacy common model len = 65
+			if self.id == 1 and self.len == 65:
+				block_len = self.len
+
+			# while another block
+			while end_addr >= block_addr + block_len:
+				block = block_class(self, block_addr, block_len, block_type, index)
+				self.blocks.append(block)
+
+				for point_type in block_type.points_list:
+					if point_type.type != suns.SUNS_TYPE_PAD:
+						point_addr = int(block_addr) + int(point_type.offset)
+						point = point_class(block, point_type, str(point_addr))
+						if point_addr + point.point_type.len - last_read_addr > MAX_READ_COUNT:
+							last_read_addr = point_addr
+							self.read_blocks.append(last_read_addr)
+						if point_type.type == suns.SUNS_TYPE_SUNSSF:
+							block.points_sf[point_type.id] = point
+						else:
+							block.points_list.append(point)
+							block.points[point_type.id] = point
+
+				# resolve scale factor addresses for repeating block
+				for point in block.points_list:
+					if point.point_type.sf is not None and point.sf_point is None:
+						# check for constant scale factor
+						try:
+							sf_value = int(point.point_type.sf)
+							point.sf_point = ScaleFactor(sf_value)
+						except Exception:
+							pass
+						# try local repeating block first
+						if point.sf_point is None:
+							point.sf_point = block.points_sf.get(point.point_type.sf)
+						if point.sf_point is None:
+							# if repeating block, try fixed block
+							if index > 0:
+								point.sf_point = self.blocks[0].points_sf.get(point.point_type.sf)
+						if point.sf_point is None:
+							# ### what state should model be left in on exception
+							raise SunSpecError('Unable to resolve scale factor point %s for point %s in model %s' %
+								point.point_type.sf, point.point_type.pid, self.id)
+
+				block_addr += block_len
+				block_type = self.model_type.repeating_block
+				if block_type is None:
+					### check for extra registers?
+					break
+				index += 1
+				block_len = int(block_type.len)
+		else:
+			raise SunSpecError('Unknown model type - id: %s' % str(self.id))
+
+		# expose fixed block points at model level if present
+		try:
+			self.points_list = self.blocks[0].points_list
+			self.points = self.blocks[0].points
+			self.points_sf = self.blocks[0].points_sf
+		except IndexError:
+			pass
+
+	def from_pics(self, element):
+
+		# update index if present
+		self.index = element.attrib.get(pics.PICS_ATTR_INDEX, self.index)
+
+		for b in element.findall('*'):
+			if b.tag != pics.PICS_BLOCK:
+				raise SunSpecError("Unexpected '%s' element in '%s' element" % (b.tag, element.tag))
+			block_type = pics.pics_block_types.get(b.attrib.get(pics.PICS_ATTR_TYPE, pics.PICS_TYPE_FIXED))
+			if block_type is None:
+				raise SunSpecError('Unknown block type')
+			if block_type == suns.SUNS_BLOCK_FIXED:
+				if len(self.blocks) > 0:
+					self.blocks[0].from_pics(b)
+			elif block_type == suns.SUNS_BLOCK_REPEATING:
+				block_index = b.attrib.get(pics.PICS_ATTR_INDEX)
+				# if no index specified, apply to all repeating blocks
+				if block_index is None:
+					if len(self.blocks) > 1:
+						for block in self.blocks[1:]:
+							block.from_pics(b)
+				else:
+					block_index = int(block_index)
+					if len(self.blocks) < block_index:
+						raise SunSpecError('Block index out of range: %s' % (str(block_index)))
+					self.blocks[block_index].from_pics(b)
+			else:
+				raise SunSpecError('Internal block type error')
+
+	def to_pics(self, parent, single_repeating=True):
+
+		attr = {pics.PICS_ATTR_ID: str(self.id), pics.PICS_ATTR_LEN: str(self.len)}
+
+		if self.index != 1:
+			attr[pics.PICS_ATTR_INDEX] = str(self.index)
+
+		e = ET.SubElement(parent, pics.PICS_MODEL, attrib=attr)
+
+		for block in self.blocks:
+			if single_repeating == False or block.index <= 1:
+				block.to_pics(e)
+
+	def not_equal(self, model):
+
+		if len(self.blocks) != len(model.blocks):
+			return 'model %s not equal - block counts: %d  %d' % (self.model_type.id, len(self.blocks), len(model.blocks))
+		s = self.model_type.not_equal(model.model_type)
+		if s:
+			return 'model %s not equal - model id not equal: %s' % (self.model_type.id, s)
+
+		for i in range(len(self.blocks)):
+			s = self.blocks[i].not_equal(model.blocks[i])
+			if s:
+				return 'model %s not equal - %s' % (self.model_type.id, s)
+		return False
+
+	def __str__(self):
+
+		model_str = 'Model %s:\n' % self.id
+		for point in self.points_list:
+			model_str += '  ' + str(point) + '\n'
+		for block in self.blocks[1:]:
+			model_str += str(block)
+		return model_str
 
 
 model_type_path_default = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'models', 'smdx')
@@ -529,365 +529,365 @@ model_types = {}
 
 def model_type_get(model_id):
 
-    global file_pathlist
-    global model_types
+	global file_pathlist
+	global model_types
 
-    model_type = model_types.get(str(model_id))
-    if model_type is None:
-        smdx_data = ''
-        # create model file name
-        filename = smdx.model_id_to_filename(model_id)
+	model_type = model_types.get(str(model_id))
+	if model_type is None:
+		smdx_data = ''
+		# create model file name
+		filename = smdx.model_id_to_filename(model_id)
  
-        # check in file path list if set
-        if file_pathlist is not None:
-            try:
-                smdx_data = file_pathlist.read(filename)
-            except NameError:
-                pass
-
-        if not smdx_data:
-            if not os.path.exists(filename):
-                filename = os.path.join(model_type_path_default, filename)
-
-            if os.path.exists(filename):
-                try:
-                    f = open(filename, 'r')
-                    smdx_data = f.read()
-                    f.close()
-                except Exception, e:
-                    raise SunSpecError('Error loading model %s at %s: %s' % (model_id, filename, str(e)))
-      
-        if smdx_data:
-            root = ET.fromstring(smdx_data)
-
-            # load model type
-            try:
-                model_type = ModelType()
-                model_type.from_smdx(root)
-                model_types[model_type.id] = model_type
-            except Exception, e:
-                raise SunSpecError('Error loading model %s at %s: %s' % (model_id, filename, str(e)))
-        else:
-            raise SunSpecError('Model file for model %s not found' % (str(model_id)))
-
-    return model_type
+		# check in file path list if set
+		if file_pathlist is not None:
+			try:
+				smdx_data = file_pathlist.read(filename)
+			except NameError:
+				pass
+
+		if not smdx_data:
+			if not os.path.exists(filename):
+				filename = os.path.join(model_type_path_default, filename)
+
+			if os.path.exists(filename):
+				try:
+					f = open(filename, 'r')
+					smdx_data = f.read()
+					f.close()
+				except Exception as e:
+					raise SunSpecError('Error loading model %s at %s: %s' % (model_id, filename, str(e)))
+	  
+		if smdx_data:
+			root = ET.fromstring(smdx_data)
+
+			# load model type
+			try:
+				model_type = ModelType()
+				model_type.from_smdx(root)
+				model_types[model_type.id] = model_type
+			except Exception as e:
+				raise SunSpecError('Error loading model %s at %s: %s' % (model_id, filename, str(e)))
+		else:
+			raise SunSpecError('Model file for model %s not found' % (str(model_id)))
+
+	return model_type
 
 class ModelType(object):
 
-    def __init__(self, mid=None):
-
-        self.id = mid
-        self.len = None
-        self.name = None
-        self.label = None
-        self.description = None
-        self.notes = None
-        self.fixed_block = None
-        self.repeating_block = None
-        self.symbols = {}
-
-    def from_smdx(self, element):
-
-        smdx_data = ''
-
-        for m in element.findall(smdx.SMDX_MODEL):
-            if True:
-                self.id = int(m.attrib.get(smdx.SMDX_ATTR_ID))
-                self.len = m.attrib.get(smdx.SMDX_ATTR_LEN)
-                self.name = m.attrib.get(smdx.SMDX_ATTR_NAME)
-                if self.name is None:
-                    self.name = 'model_' + str(self.id)
-
-                if self.len is None:
-                    raise SunSpecError('Module len error')
-                self.len = int(self.len)
-
-                for b in m.findall(smdx.SMDX_BLOCK):
-                    block = BlockType(model_type=self)
-                    block.from_smdx(b)
-
-                    if block.type == suns.SUNS_BLOCK_FIXED:
-                        if self.fixed_block is None:
-                            self.fixed_block = block
-                        else:
-                            raise SunSpecError('Duplicate fixed block type definition')
-                    elif block.type == suns.SUNS_BLOCK_REPEATING:
-                        if self.repeating_block is None:
-                            self.repeating_block = block
-                        else:
-                            raise SunSpecError('Duplicate repeating block type definition')
-                break
-            else:
-                raise SunSpecError('Unexpected smdx element: %s' % m.tag)
-
-        for s in element.findall(smdx.SMDX_STRINGS):
-            if s.attrib.get(smdx.SMDX_ATTR_ID) == str(self.id):
-                m = s.find(smdx.SMDX_MODEL)
-                if m is not None:
-                    for e in m.findall('*'):
-                        if e.tag == smdx.SMDX_LABEL:
-                            self.label = e.text
-                        elif e.tag == smdx.SMDX_DESCRIPTION:
-                            self.description = e.text
-                        elif e.tag == smdx.SMDX_NOTES:
-                            self.notes = e.text
-                for e in s.findall(smdx.SMDX_POINT):
-                    pid = e.attrib.get(smdx.SMDX_ATTR_ID)
-                    point_type = None
-                    if self.fixed_block is not None:
-                        point_type = self.fixed_block.points.get(pid)
-                    if point_type is None and self.repeating_block is not None:
-                        point_type = self.repeating_block.points.get(pid)
-                    if point_type:
-                        point_type.from_smdx(e, strings=True)
-
-        if self.fixed_block is None:
-            self.fixed_block = BlockType(suns.SUNS_BLOCK_FIXED, model_type=self)
-
-    def symbol_add(self, symbol):
-        self.symbols[symbol.id] = symbol
-
-    def symbol_get(self, sid):
-        return self.symbols.get(sid)
-
-    def not_equal(self, model_type):
-
-        if self == model_type:
-            return False
-
-        if model_type is None:
-            return "ModelType is None"
-        if self.id != model_type.id:
-            return "ModelType attribute 'id' not equal: %s  %s" % (str(self.id), str(model_type.id))
-        if self.len != model_type.len:
-            return "ModelType attribute 'len' not equal: %s  %s" % (str(self.len), str(model_type.len))
-        if self.label != model_type.label:
-            return "ModelType attribute 'label' not equal: %s  %s" % (str(self.label), str(model_type.label))
-        if self.description != model_type.description:
-            return "ModelType attribute 'description' not equal: %s  %s" % (str(self.description), str(model_type.description))
-        if self.notes != model_type.notes:
-            return "ModelType attribute 'notes' not equal: %s  %s" % (str(self.notes), str(model_type.notes))
-        if self.fixed_block is not None:
-            not_equal = self.fixed_block.not_equal(model_type.fixed_block)
-            if not_equal:
-                return not_equal
-        elif model_type.fixed_block is not None:
-            return "ModelType fixed block is None"
-        if self.repeating_block is not None:
-            not_equal = self.repeating_block.not_equal(model_type.repeating_block)
-            if not_equal:
-                return not_equal
-        elif model_type.repeating_block is not None:
-            return "ModelType repeating block is None"
-
-        return False
-
-    def __str__(self):
-
-        s = 'ModelType: id = %s len = %s\n' % (self.id, self.len)
-        if self.fixed_block:
-            s += str(self.fixed_block)
-        if self.repeating_block:
-            s += str(self.repeating_block)
-        return s
+	def __init__(self, mid=None):
+
+		self.id = mid
+		self.len = None
+		self.name = None
+		self.label = None
+		self.description = None
+		self.notes = None
+		self.fixed_block = None
+		self.repeating_block = None
+		self.symbols = {}
+
+	def from_smdx(self, element):
+
+		smdx_data = ''
+
+		for m in element.findall(smdx.SMDX_MODEL):
+			if True:
+				self.id = int(m.attrib.get(smdx.SMDX_ATTR_ID))
+				self.len = m.attrib.get(smdx.SMDX_ATTR_LEN)
+				self.name = m.attrib.get(smdx.SMDX_ATTR_NAME)
+				if self.name is None:
+					self.name = 'model_' + str(self.id)
+
+				if self.len is None:
+					raise SunSpecError('Module len error')
+				self.len = int(self.len)
+
+				for b in m.findall(smdx.SMDX_BLOCK):
+					block = BlockType(model_type=self)
+					block.from_smdx(b)
+
+					if block.type == suns.SUNS_BLOCK_FIXED:
+						if self.fixed_block is None:
+							self.fixed_block = block
+						else:
+							raise SunSpecError('Duplicate fixed block type definition')
+					elif block.type == suns.SUNS_BLOCK_REPEATING:
+						if self.repeating_block is None:
+							self.repeating_block = block
+						else:
+							raise SunSpecError('Duplicate repeating block type definition')
+				break
+			else:
+				raise SunSpecError('Unexpected smdx element: %s' % m.tag)
+
+		for s in element.findall(smdx.SMDX_STRINGS):
+			if s.attrib.get(smdx.SMDX_ATTR_ID) == str(self.id):
+				m = s.find(smdx.SMDX_MODEL)
+				if m is not None:
+					for e in m.findall('*'):
+						if e.tag == smdx.SMDX_LABEL:
+							self.label = e.text
+						elif e.tag == smdx.SMDX_DESCRIPTION:
+							self.description = e.text
+						elif e.tag == smdx.SMDX_NOTES:
+							self.notes = e.text
+				for e in s.findall(smdx.SMDX_POINT):
+					pid = e.attrib.get(smdx.SMDX_ATTR_ID)
+					point_type = None
+					if self.fixed_block is not None:
+						point_type = self.fixed_block.points.get(pid)
+					if point_type is None and self.repeating_block is not None:
+						point_type = self.repeating_block.points.get(pid)
+					if point_type:
+						point_type.from_smdx(e, strings=True)
+
+		if self.fixed_block is None:
+			self.fixed_block = BlockType(suns.SUNS_BLOCK_FIXED, model_type=self)
+
+	def symbol_add(self, symbol):
+		self.symbols[symbol.id] = symbol
+
+	def symbol_get(self, sid):
+		return self.symbols.get(sid)
+
+	def not_equal(self, model_type):
+
+		if self == model_type:
+			return False
+
+		if model_type is None:
+			return "ModelType is None"
+		if self.id != model_type.id:
+			return "ModelType attribute 'id' not equal: %s  %s" % (str(self.id), str(model_type.id))
+		if self.len != model_type.len:
+			return "ModelType attribute 'len' not equal: %s  %s" % (str(self.len), str(model_type.len))
+		if self.label != model_type.label:
+			return "ModelType attribute 'label' not equal: %s  %s" % (str(self.label), str(model_type.label))
+		if self.description != model_type.description:
+			return "ModelType attribute 'description' not equal: %s  %s" % (str(self.description), str(model_type.description))
+		if self.notes != model_type.notes:
+			return "ModelType attribute 'notes' not equal: %s  %s" % (str(self.notes), str(model_type.notes))
+		if self.fixed_block is not None:
+			not_equal = self.fixed_block.not_equal(model_type.fixed_block)
+			if not_equal:
+				return not_equal
+		elif model_type.fixed_block is not None:
+			return "ModelType fixed block is None"
+		if self.repeating_block is not None:
+			not_equal = self.repeating_block.not_equal(model_type.repeating_block)
+			if not_equal:
+				return not_equal
+		elif model_type.repeating_block is not None:
+			return "ModelType repeating block is None"
+
+		return False
+
+	def __str__(self):
+
+		s = 'ModelType: id = %s len = %s\n' % (self.id, self.len)
+		if self.fixed_block:
+			s += str(self.fixed_block)
+		if self.repeating_block:
+			s += str(self.repeating_block)
+		return s
 
 class BlockType(object):
 
-    def __init__(self, btype=None, blen=0, name=None, model_type=None):
-        self.model_type = model_type
-        self.type = btype
-        self.len = blen
-        self.name = name
-        self.points_list = []
-        self.points = {}
-
-    def from_smdx(self, element):
-
-        btype = element.attrib.get(smdx.SMDX_ATTR_TYPE, smdx.SMDX_ATTR_TYPE_FIXED)
-
-        if btype != smdx.SMDX_ATTR_TYPE_FIXED and btype != smdx.SMDX_ATTR_TYPE_REPEATING:
-            raise SunSpecError('Invalid block type')
-
-        self.type = smdx.smdx_block_types.get(btype)
-        self.len = element.attrib.get(smdx.SMDX_ATTR_LEN)
-        if self.len is None:
-            raise SunSpecError('Block len error')
-        self.name = element.attrib.get(smdx.SMDX_ATTR_NAME)
-        if self.name is None:
-            self.name = self.type
-
-        # process points
-        for e in element.findall(smdx.SMDX_POINT):
-            pt = PointType(block_type=self)
-            pt.from_smdx(e)
-
-            if self.points.get(pt.id) is not None:
-                ET.dump(e)
-                raise SunSpecError('Duplicate point definition: %s' % (pt.id))
-
-            self.points_list.append(pt)
-            self.points[pt.id] = pt
-
-    def not_equal(self, block_type):
-
-        if self == block_type:
-            return False
-
-        if block_type is None:
-            return "BlockType '%s' is none" % (str(self.type))
-        if self.type != block_type.type:
-            return "BlockType attribute 'type' not equal: %s  %s" % (str(self.type), str(block_type.type))
-        if self.len != block_type.len:
-            return "BlockType attribute 'len' not equal: %s  %s" % (str(self.len), str(block_type.len))
-        if len(self.points) != len(block_type.points):
-            return "BlockType '%s' point count not equal" % (str(self.type))
-        for k, v in self.points.items():
-            value = block_type.points.get(k)
-            not_equal =  v.not_equal(value)
-            if not_equal:
-                return not_equal
-
-        return False
-
-    def __str__(self):
-
-        s = 'BlockType: type = %s len = %s\n' % (self.type, self.len)
-        for p in self.points_list:
-            s += '  %s\n' % (str(p))
-        return s
+	def __init__(self, btype=None, blen=0, name=None, model_type=None):
+		self.model_type = model_type
+		self.type = btype
+		self.len = blen
+		self.name = name
+		self.points_list = []
+		self.points = {}
+
+	def from_smdx(self, element):
+
+		btype = element.attrib.get(smdx.SMDX_ATTR_TYPE, smdx.SMDX_ATTR_TYPE_FIXED)
+
+		if btype != smdx.SMDX_ATTR_TYPE_FIXED and btype != smdx.SMDX_ATTR_TYPE_REPEATING:
+			raise SunSpecError('Invalid block type')
+
+		self.type = smdx.smdx_block_types.get(btype)
+		self.len = element.attrib.get(smdx.SMDX_ATTR_LEN)
+		if self.len is None:
+			raise SunSpecError('Block len error')
+		self.name = element.attrib.get(smdx.SMDX_ATTR_NAME)
+		if self.name is None:
+			self.name = self.type
+
+		# process points
+		for e in element.findall(smdx.SMDX_POINT):
+			pt = PointType(block_type=self)
+			pt.from_smdx(e)
+
+			if self.points.get(pt.id) is not None:
+				ET.dump(e)
+				raise SunSpecError('Duplicate point definition: %s' % (pt.id))
+
+			self.points_list.append(pt)
+			self.points[pt.id] = pt
+
+	def not_equal(self, block_type):
+
+		if self == block_type:
+			return False
+
+		if block_type is None:
+			return "BlockType '%s' is none" % (str(self.type))
+		if self.type != block_type.type:
+			return "BlockType attribute 'type' not equal: %s  %s" % (str(self.type), str(block_type.type))
+		if self.len != block_type.len:
+			return "BlockType attribute 'len' not equal: %s  %s" % (str(self.len), str(block_type.len))
+		if len(self.points) != len(block_type.points):
+			return "BlockType '%s' point count not equal" % (str(self.type))
+		for k, v in self.points.items():
+			value = block_type.points.get(k)
+			not_equal =  v.not_equal(value)
+			if not_equal:
+				return not_equal
+
+		return False
+
+	def __str__(self):
+
+		s = 'BlockType: type = %s len = %s\n' % (self.type, self.len)
+		for p in self.points_list:
+			s += '  %s\n' % (str(p))
+		return s
 
 class PointType(object):
 
-    def __init__(self, pid=None, offset=None, ptype=None, plen=None, mandatory=None, access=None, sf=None,
-                 block_type=None):
-        self.block_type = block_type
-        self.id = pid
-        self.offset = offset
-        self.type = ptype
-        self.len = plen
-        self.mandatory = mandatory
-        self.access = access
-        self.units = None
-        self.sf = sf
-        self.label = None
-        self.description = None
-        self.notes = None
-        self.value_default = None
-        self.is_impl = None
-        self.data_to = None
-        self.to_data = None
-        self.to_value = None
-        self.symbols = []
-
-    def from_smdx(self, element, strings=False):
-
-        for e in element.findall('*'):
-            if e.tag == smdx.SMDX_LABEL:
-                self.label = e.text
-            elif e.tag == smdx.SMDX_DESCRIPTION:
-                self.description = e.text
-            elif e.tag == smdx.SMDX_NOTES:
-                self.notes = e.text
-            elif e.tag == smdx.SMDX_SYMBOL:
-                sid = e.attrib.get(smdx.SMDX_ATTR_ID)
-                symbol = self.block_type.model_type.symbol_get(sid)
-                if symbol is None:
-                    symbol = Symbol()
-                    symbol.from_smdx(e, strings)
-                    self.block_type.model_type.symbol_add(symbol)
-                if self.symbol_get(sid) is None:
-                    self.symbols.append(symbol)
-                symbol.from_smdx(e, strings)
-
-        if strings is False:
-            self.id = element.attrib.get(smdx.SMDX_ATTR_ID)
-            self.offset = int(element.attrib.get(smdx.SMDX_ATTR_OFFSET))
-            ptype = element.attrib.get(smdx.SMDX_ATTR_TYPE)
-            plen = element.attrib.get(smdx.SMDX_ATTR_LEN)
-            mandatory = element.attrib.get(smdx.SMDX_ATTR_MANDATORY, smdx.SMDX_MANDATORY_FALSE)
-            access = element.attrib.get(smdx.SMDX_ATTR_ACCESS, smdx.SMDX_ACCESS_R)
-            self.units = element.attrib.get(smdx.SMDX_ATTR_UNITS)
-
-            if self.id is None:
-                raise SunSpecError('Missing point id attribute')
-            if self.offset is None:
-                raise SunSpecError('Missing offset attribute for point: %s' % self.id)
-            if ptype is None:
-                raise SunSpecError('Missing type attribute for point: %s' % self.id)
-            if ptype == smdx.SMDX_TYPE_STRING and plen is None:
-                raise SunSpecError('Missing len attribute for point: %s' % self.id)
-
-            self.type = smdx.smdx_point_types.get(ptype)
-            if self.type is None:
-                raise SunSpecError('Unknown point type: %s' % ptype)
-            self.mandatory = smdx.smdx_mandatory_types.get(mandatory)
-            if self.mandatory is None:
-                raise SunSpecError('Unknown mandatory type: %s' % mandatory)
-            self.access = smdx.smdx_access_types.get(access)
-            if self.access is None:
-                raise SunSpecError('Unknown access type: %s' % access)
-            self.sf = element.attrib.get(smdx.SMDX_ATTR_SF)
-
-            info = suns.suns_point_type_info.get(self.type)
-
-            if info is not None:
-                self.len, self.is_impl, self.data_to, self.to_data, self.to_value, self.value_default = info
-                if plen is not None:
-                    self.len = int(plen)
-
-    def symbol_get(self, sid):
-        for symbol in self.symbols:
-            if symbol.id == sid:
-                return symbol
-
-    def not_equal(self, point_type):
-
-        if self == point_type:
-            return False
-
-        if point_type is None:
-            return "PointType '%s' is None" % (str(self.id))
-        if len(self.__dict__) != len(point_type.__dict__):
-            return "PointType '%s' attribute count not equal': %s  %s" % (str(self.id))
-        for k, v in self.__dict__.items():
-            if k != 'block_type':
-                value = point_type.__dict__.get(k)
-                if v is not None and value is not None:
-                    if value is None or v != value:
-                        return "PointType '%s' attribute '%s' not equal: %s  %s" % (str(self.id), str(k), str(v), str(value))
-
-        return False
-
-    def __str__(self):
-
-        return 'PointType: id = %s offset = %d type = %s len = %d sf = %s access = %s mandatory = %s' % \
-            (self.id, self.offset, self.type, self.len, self.sf, self.access, self.mandatory)
+	def __init__(self, pid=None, offset=None, ptype=None, plen=None, mandatory=None, access=None, sf=None,
+				 block_type=None):
+		self.block_type = block_type
+		self.id = pid
+		self.offset = offset
+		self.type = ptype
+		self.len = plen
+		self.mandatory = mandatory
+		self.access = access
+		self.units = None
+		self.sf = sf
+		self.label = None
+		self.description = None
+		self.notes = None
+		self.value_default = None
+		self.is_impl = None
+		self.data_to = None
+		self.to_data = None
+		self.to_value = None
+		self.symbols = []
+
+	def from_smdx(self, element, strings=False):
+
+		for e in element.findall('*'):
+			if e.tag == smdx.SMDX_LABEL:
+				self.label = e.text
+			elif e.tag == smdx.SMDX_DESCRIPTION:
+				self.description = e.text
+			elif e.tag == smdx.SMDX_NOTES:
+				self.notes = e.text
+			elif e.tag == smdx.SMDX_SYMBOL:
+				sid = e.attrib.get(smdx.SMDX_ATTR_ID)
+				symbol = self.block_type.model_type.symbol_get(sid)
+				if symbol is None:
+					symbol = Symbol()
+					symbol.from_smdx(e, strings)
+					self.block_type.model_type.symbol_add(symbol)
+				if self.symbol_get(sid) is None:
+					self.symbols.append(symbol)
+				symbol.from_smdx(e, strings)
+
+		if strings is False:
+			self.id = element.attrib.get(smdx.SMDX_ATTR_ID)
+			self.offset = int(element.attrib.get(smdx.SMDX_ATTR_OFFSET))
+			ptype = element.attrib.get(smdx.SMDX_ATTR_TYPE)
+			plen = element.attrib.get(smdx.SMDX_ATTR_LEN)
+			mandatory = element.attrib.get(smdx.SMDX_ATTR_MANDATORY, smdx.SMDX_MANDATORY_FALSE)
+			access = element.attrib.get(smdx.SMDX_ATTR_ACCESS, smdx.SMDX_ACCESS_R)
+			self.units = element.attrib.get(smdx.SMDX_ATTR_UNITS)
+
+			if self.id is None:
+				raise SunSpecError('Missing point id attribute')
+			if self.offset is None:
+				raise SunSpecError('Missing offset attribute for point: %s' % self.id)
+			if ptype is None:
+				raise SunSpecError('Missing type attribute for point: %s' % self.id)
+			if ptype == smdx.SMDX_TYPE_STRING and plen is None:
+				raise SunSpecError('Missing len attribute for point: %s' % self.id)
+
+			self.type = smdx.smdx_point_types.get(ptype)
+			if self.type is None:
+				raise SunSpecError('Unknown point type: %s' % ptype)
+			self.mandatory = smdx.smdx_mandatory_types.get(mandatory)
+			if self.mandatory is None:
+				raise SunSpecError('Unknown mandatory type: %s' % mandatory)
+			self.access = smdx.smdx_access_types.get(access)
+			if self.access is None:
+				raise SunSpecError('Unknown access type: %s' % access)
+			self.sf = element.attrib.get(smdx.SMDX_ATTR_SF)
+
+			info = suns.suns_point_type_info.get(self.type)
+
+			if info is not None:
+				self.len, self.is_impl, self.data_to, self.to_data, self.to_value, self.value_default = info
+				if plen is not None:
+					self.len = int(plen)
+
+	def symbol_get(self, sid):
+		for symbol in self.symbols:
+			if symbol.id == sid:
+				return symbol
+
+	def not_equal(self, point_type):
+
+		if self == point_type:
+			return False
+
+		if point_type is None:
+			return "PointType '%s' is None" % (str(self.id))
+		if len(self.__dict__) != len(point_type.__dict__):
+			return "PointType '%s' attribute count not equal': %s  %s" % (str(self.id))
+		for k, v in self.__dict__.items():
+			if k != 'block_type':
+				value = point_type.__dict__.get(k)
+				if v is not None and value is not None:
+					if value is None or v != value:
+						return "PointType '%s' attribute '%s' not equal: %s  %s" % (str(self.id), str(k), str(v), str(value))
+
+		return False
+
+	def __str__(self):
+
+		return 'PointType: id = %s offset = %d type = %s len = %d sf = %s access = %s mandatory = %s' % \
+			(self.id, self.offset, self.type, self.len, self.sf, self.access, self.mandatory)
 
 class Symbol(object):
 
-    def __init__(self, sid=None):
-        self.id = sid
-        self.value = None
-        self.label = None
-        self.description = None
-        self.notes = None
+	def __init__(self, sid=None):
+		self.id = sid
+		self.value = None
+		self.label = None
+		self.description = None
+		self.notes = None
 
-    def from_smdx(self, element, strings=False):
+	def from_smdx(self, element, strings=False):
 
-        for e in element.findall('*'):
-            if e.tag == smdx.SMDX_LABEL:
-                self.label = e.text
-            elif e.tag == smdx.SMDX_DESCRIPTION:
-                self.description = e.text
-            elif e.tag == smdx.SMDX_NOTES:
-                self.notes = e.text
+		for e in element.findall('*'):
+			if e.tag == smdx.SMDX_LABEL:
+				self.label = e.text
+			elif e.tag == smdx.SMDX_DESCRIPTION:
+				self.description = e.text
+			elif e.tag == smdx.SMDX_NOTES:
+				self.notes = e.text
 
-        if strings is False:
-            self.id = element.attrib.get(smdx.SMDX_ATTR_ID)
-            self.value = element.text
-            if self.id is None:
-                raise SunSpecError('Missing point id attribute')
+		if strings is False:
+			self.id = element.attrib.get(smdx.SMDX_ATTR_ID)
+			self.value = element.text
+			if self.id is None:
+				raise SunSpecError('Missing point id attribute')
 
-    def __str__(self):
+	def __str__(self):
 
-        return 'Symbol: id = %s value = %s' % (self.id, self.value)
+		return 'Symbol: id = %s value = %s' % (self.id, self.value)
diff --git a/sunspec/core/modbus/client.py b/sunspec/core/modbus/client.py
index 6a43eb5..6d29ede 100644
--- a/sunspec/core/modbus/client.py
+++ b/sunspec/core/modbus/client.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2017 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import os
@@ -27,9 +27,9 @@ import struct
 import serial
 
 try:
-    import xml.etree.ElementTree as ET
+	import xml.etree.ElementTree as ET
 except:
-    import elementtree.ElementTree as ET
+	import elementtree.ElementTree as ET
 
 import sunspec.core.modbus.mbmap as mbmap
 
@@ -47,283 +47,283 @@ TEST_NAME = 'test_name'
 modbus_rtu_clients = {}
 
 class ModbusClientError(Exception):
-    pass
+	pass
 
 class ModbusClientTimeout(ModbusClientError):
-    pass
+	pass
 
 class ModbusClientException(ModbusClientError):
-    pass
+	pass
 
 def modbus_rtu_client(name=None, baudrate=None, parity=None):
 
-    global modbus_rtu_clients
+	global modbus_rtu_clients
 
-    client = modbus_rtu_clients.get(name)
-    if client is not None:
-        if baudrate is not None and client.baudrate != baudrate:
-            raise ModbusClientError('Modbus client baudrate mismatch')
-        if parity is not None and client.parity != parity:
-            raise ModbusClientError('Modbus client parity mismatch')
-    else:
-        if baudrate is None:
-            baudrate = 9600
-        if parity is None:
-            parity = PARITY_NONE
+	client = modbus_rtu_clients.get(name)
+	if client is not None:
+		if baudrate is not None and client.baudrate != baudrate:
+			raise ModbusClientError('Modbus client baudrate mismatch')
+		if parity is not None and client.parity != parity:
+			raise ModbusClientError('Modbus client parity mismatch')
+	else:
+		if baudrate is None:
+			baudrate = 9600
+		if parity is None:
+			parity = PARITY_NONE
 
-        client = ModbusClientRTU(name, baudrate, parity)
-        modbus_rtu_clients[name] = client
+		client = ModbusClientRTU(name, baudrate, parity)
+		modbus_rtu_clients[name] = client
 
-    return client
+	return client
 
 def modbus_rtu_client_remove(name=None):
 
-    global modbus_rtu_clients
+	global modbus_rtu_clients
 
-    if modbus_rtu_clients.get(name):
-        del modbus_rtu_clients[name]
+	if modbus_rtu_clients.get(name):
+		del modbus_rtu_clients[name]
 
 class ModbusClientRTU(object):
 
-    def __init__(self, name='/dev/ttyUSB0', baudrate=9600, parity=None):
-        self.name = name
-        self.baudrate = baudrate
-        self.parity = parity
-        self.serial = None
-        self.timeout = .5
-        self.write_timeout = .5
-        self.devices = {}
-
-        self.open()
-        
-    def open(self):
-
-        try:
-            if self.parity == PARITY_EVEN:
-                parity = serial.PARITY_EVEN
-            else:
-                parity = serial.PARITY_NONE
-
-            if self.name != TEST_NAME:
-                self.serial = serial.Serial(port = self.name, baudrate=self.baudrate,
-                                            bytesize=8, parity=parity,
-                                            stopbits=1, xonxoff=0,
-                                            timeout=self.timeout, writeTimeout=self.write_timeout)
-            else:
-                import sunspec.core.test.fake.serial as fake
-                self.serial = fake.Serial(port = self.name, baudrate=self.baudrate,
-                                          bytesize=8, parity=parity,
-                                          stopbits=1, xonxoff=0,
-                                          timeout=self.timeout, writeTimeout=self.write_timeout)
-
-        except Exception, e:
-            if self.serial is not None:
-                self.serial.close()
-                self.serial = None
-            raise ModbusClientError('Serial init error: %s' % str(e))
-
-    def close(self):
-
-        try:
-            if self.serial is not None:
-                self.serial.close()
-        except Exception, e:
-            raise ModbusClientError('Serial close error: %s' % str(e))
-
-    def add_device(self, slave_id, device):
-
-        self.devices[slave_id] = device
-
-    def remove_device(self, slave_id):
-
-        if self.devices.get(slave_id):
-            del self.devices[slave_id]
-
-        # if no more devices using the client interface, close and remove the client
-        if len(self.devices) == 0:
-            self.close()
-            modbus_rtu_client_remove(self.name)
-
-    def _read(self, slave_id, addr, count, op=FUNC_READ_HOLDING, trace_func=None):
-        resp = ''
-        len_remaining = 5
-        len_found = False
-        except_code = None
-
-        req = struct.pack('>BBHH', int(slave_id), op, int(addr), int(count))
-        req += struct.pack('>H', computeCRC(req))
-        
-        if trace_func:
-            s = '%s:%s[addr=%s] ->' % (self.name, str(slave_id), addr)
-            for c in req:
-                s += '%02X' % (ord(c))
-            trace_func(s)
-
-        self.serial.flushInput()
-        try:
-            self.serial.write(req)
-        except Exception, e:
-            raise ModbusClientError('Serial write error: %s' % str(e))
-
-        while len_remaining > 0:
-            c = self.serial.read(len_remaining)
-            len_read = len(c);
-            if len_read > 0:
-                resp += c
-                len_remaining -= len_read
-                if len_found is False and len(resp) >= 5:
-                    if not (ord(resp[1]) & 0x80):
-                        len_remaining = (ord(resp[2]) + 5) - len(resp)
-                        len_found = True
-                    else:
-                        except_code = ord(resp[2])
-            else:
-                raise ModbusClientTimeout('Response timeout')
-
-        if trace_func:
-            s = '%s:%s[addr=%s] <--' % (self.name, str(slave_id), addr)
-            for c in resp:
-                s += '%02X' % (ord(c))
-            trace_func(s)
-
-        crc = (ord(resp[-2]) << 8) | ord(resp[-1])
-        if not checkCRC(resp[:-2], crc):
-            raise ModbusClientError('CRC error')
-
-        if except_code:
-            raise ModbusClientException('Modbus exception %d' % (except_code))
-
-        return resp[3:-2]
-
-    def read(self, slave_id, addr, count, op=FUNC_READ_HOLDING, trace_func=None, max_count=REQ_COUNT_MAX):
-        resp = ''
-        read_count = 0
-        read_offset = 0
-
-        if self.serial is not None:
-            while (count > 0):
-                if count > max_count:
-                    read_count = max_count
-                else:
-                    read_count = count
-                data = self._read(slave_id, addr + read_offset, read_count, op=op, trace_func=trace_func)
-                if data:
-                    resp += data
-                    count -= read_count
-                    read_offset += read_count
-                else:
-                    return
-        else:
-            raise ModbusClientError('Client serial port not open: %s' % self.name)
-
-        return resp
-
-    def _write(self, slave_id, addr, data, trace_func=None):
-        resp = ''
-        len_remaining = 5
-        len_found = False
-        except_code = None
-        func = FUNC_WRITE_MULTIPLE
-        len_data = len(data)
-        count = len_data/2
-
-        req = struct.pack('>BBHHB', int(slave_id), func, int(addr), count, len_data)
-        req += data
-        req += struct.pack('>H', computeCRC(req))
-
-        if trace_func:
-            s = '%s:%s[addr=%s] ->' % (self.name, str(slave_id), addr)
-            for c in req:
-                s += '%02X' % (ord(c))
-            trace_func(s)
-
-        self.serial.flushInput()
-        try:
-            self.serial.write(req)
-        except Exception, e:
-            raise ModbusClientError('Serial write error: %s' % str(e))
-
-        while len_remaining > 0:
-            c = self.serial.read(len_remaining)
-            len_read = len(c);
-            if len_read > 0:
-                resp += c
-                len_remaining -= len_read
-                if len_found is False and len(resp) >= 5:
-                    if not (ord(resp[1]) & 0x80):
-                        len_remaining = 8 - len(resp)
-                        len_found = True
-                    else:
-                        except_code = ord(resp[2])
-            else:
-                raise ModbusClientTimeout('Response timeout')
-
-        if trace_func:
-            s = '%s:%s[addr=%s] <--' % (self.name, str(slave_id), addr)
-            for c in resp:
-                s += '%02X' % (ord(c))
-            trace_func(s)
-
-
-        crc = (ord(resp[-2]) << 8) | ord(resp[-1])
-        if not checkCRC(resp[:-2], crc):
-            raise ModbusClientError('CRC error')
-
-        if except_code:
-            raise ModbusClientException('Modbus exception: %d' % (except_code))
-        else:
-            resp_slave_id, resp_func, resp_addr, resp_count, resp_crc = struct.unpack('>BBHHH', resp)
-            if resp_slave_id != slave_id or resp_func != func or resp_addr != addr or resp_count != count:
-                raise ModbusClientError('Mobus response format error')
-
-    def write(self, slave_id, addr, data, trace_func=None, max_count=REQ_COUNT_MAX):
-        write_count = 0
-        write_offset = 0
-        count = len(data)/2
-
-        if self.serial is not None:
-            while (count > 0):
-                if count > max_count:
-                    write_count = max_count
-                else:
-                    write_count = count
-                self._write(slave_id, addr + write_offset, data[(write_offset * 2):((write_offset + write_count) * 2)], trace_func=trace_func)
-                count -= write_count
-                write_offset += write_count
-        else:
-            raise ModbusClientError('Client serial port not open: %s' % self.name)
+	def __init__(self, name='/dev/ttyUSB0', baudrate=9600, parity=None):
+		self.name = name
+		self.baudrate = baudrate
+		self.parity = parity
+		self.serial = None
+		self.timeout = .5
+		self.write_timeout = .5
+		self.devices = {}
+
+		self.open()
+		
+	def open(self):
+
+		try:
+			if self.parity == PARITY_EVEN:
+				parity = serial.PARITY_EVEN
+			else:
+				parity = serial.PARITY_NONE
+
+			if self.name != TEST_NAME:
+				self.serial = serial.Serial(port = self.name, baudrate=self.baudrate,
+											bytesize=8, parity=parity,
+											stopbits=1, xonxoff=0,
+											timeout=self.timeout, writeTimeout=self.write_timeout)
+			else:
+				import sunspec.core.test.fake.serial as fake
+				self.serial = fake.Serial(port = self.name, baudrate=self.baudrate,
+										  bytesize=8, parity=parity,
+										  stopbits=1, xonxoff=0,
+										  timeout=self.timeout, writeTimeout=self.write_timeout)
+
+		except Exception as e:
+			if self.serial is not None:
+				self.serial.close()
+				self.serial = None
+			raise ModbusClientError('Serial init error: %s' % str(e))
+
+	def close(self):
+
+		try:
+			if self.serial is not None:
+				self.serial.close()
+		except Exception as e:
+			raise ModbusClientError('Serial close error: %s' % str(e))
+
+	def add_device(self, slave_id, device):
+
+		self.devices[slave_id] = device
+
+	def remove_device(self, slave_id):
+
+		if self.devices.get(slave_id):
+			del self.devices[slave_id]
+
+		# if no more devices using the client interface, close and remove the client
+		if len(self.devices) == 0:
+			self.close()
+			modbus_rtu_client_remove(self.name)
+
+	def _read(self, slave_id, addr, count, op=FUNC_READ_HOLDING, trace_func=None):
+		resp = ''
+		len_remaining = 5
+		len_found = False
+		except_code = None
+
+		req = struct.pack('>BBHH', int(slave_id), op, int(addr), int(count))
+		req += struct.pack('>H', computeCRC(req))
+		
+		if trace_func:
+			s = '%s:%s[addr=%s] ->' % (self.name, str(slave_id), addr)
+			for c in req:
+				s += '%02X' % (ord(c))
+			trace_func(s)
+
+		self.serial.flushInput()
+		try:
+			self.serial.write(req)
+		except Exception as e:
+			raise ModbusClientError('Serial write error: %s' % str(e))
+
+		while len_remaining > 0:
+			c = self.serial.read(len_remaining)
+			len_read = len(c);
+			if len_read > 0:
+				resp += c
+				len_remaining -= len_read
+				if len_found is False and len(resp) >= 5:
+					if not (ord(resp[1]) & 0x80):
+						len_remaining = (ord(resp[2]) + 5) - len(resp)
+						len_found = True
+					else:
+						except_code = ord(resp[2])
+			else:
+				raise ModbusClientTimeout('Response timeout')
+
+		if trace_func:
+			s = '%s:%s[addr=%s] <--' % (self.name, str(slave_id), addr)
+			for c in resp:
+				s += '%02X' % (ord(c))
+			trace_func(s)
+
+		crc = (ord(resp[-2]) << 8) | ord(resp[-1])
+		if not checkCRC(resp[:-2], crc):
+			raise ModbusClientError('CRC error')
+
+		if except_code:
+			raise ModbusClientException('Modbus exception %d' % (except_code))
+
+		return resp[3:-2]
+
+	def read(self, slave_id, addr, count, op=FUNC_READ_HOLDING, trace_func=None, max_count=REQ_COUNT_MAX):
+		resp = ''
+		read_count = 0
+		read_offset = 0
+
+		if self.serial is not None:
+			while (count > 0):
+				if count > max_count:
+					read_count = max_count
+				else:
+					read_count = count
+				data = self._read(slave_id, addr + read_offset, read_count, op=op, trace_func=trace_func)
+				if data:
+					resp += data
+					count -= read_count
+					read_offset += read_count
+				else:
+					return
+		else:
+			raise ModbusClientError('Client serial port not open: %s' % self.name)
+
+		return resp
+
+	def _write(self, slave_id, addr, data, trace_func=None):
+		resp = ''
+		len_remaining = 5
+		len_found = False
+		except_code = None
+		func = FUNC_WRITE_MULTIPLE
+		len_data = len(data)
+		count = len_data/2
+
+		req = struct.pack('>BBHHB', int(slave_id), func, int(addr), count, len_data)
+		req += data
+		req += struct.pack('>H', computeCRC(req))
+
+		if trace_func:
+			s = '%s:%s[addr=%s] ->' % (self.name, str(slave_id), addr)
+			for c in req:
+				s += '%02X' % (ord(c))
+			trace_func(s)
+
+		self.serial.flushInput()
+		try:
+			self.serial.write(req)
+		except Exception as e:
+			raise ModbusClientError('Serial write error: %s' % str(e))
+
+		while len_remaining > 0:
+			c = self.serial.read(len_remaining)
+			len_read = len(c);
+			if len_read > 0:
+				resp += c
+				len_remaining -= len_read
+				if len_found is False and len(resp) >= 5:
+					if not (ord(resp[1]) & 0x80):
+						len_remaining = 8 - len(resp)
+						len_found = True
+					else:
+						except_code = ord(resp[2])
+			else:
+				raise ModbusClientTimeout('Response timeout')
+
+		if trace_func:
+			s = '%s:%s[addr=%s] <--' % (self.name, str(slave_id), addr)
+			for c in resp:
+				s += '%02X' % (ord(c))
+			trace_func(s)
+
+
+		crc = (ord(resp[-2]) << 8) | ord(resp[-1])
+		if not checkCRC(resp[:-2], crc):
+			raise ModbusClientError('CRC error')
+
+		if except_code:
+			raise ModbusClientException('Modbus exception: %d' % (except_code))
+		else:
+			resp_slave_id, resp_func, resp_addr, resp_count, resp_crc = struct.unpack('>BBHHH', resp)
+			if resp_slave_id != slave_id or resp_func != func or resp_addr != addr or resp_count != count:
+				raise ModbusClientError('Mobus response format error')
+
+	def write(self, slave_id, addr, data, trace_func=None, max_count=REQ_COUNT_MAX):
+		write_count = 0
+		write_offset = 0
+		count = len(data)/2
+
+		if self.serial is not None:
+			while (count > 0):
+				if count > max_count:
+					write_count = max_count
+				else:
+					write_count = count
+				self._write(slave_id, addr + write_offset, data[(write_offset * 2):((write_offset + write_count) * 2)], trace_func=trace_func)
+				count -= write_count
+				write_offset += write_count
+		else:
+			raise ModbusClientError('Client serial port not open: %s' % self.name)
 
 class ModbusClientDeviceRTU(object):
 
-    def __init__(self, slave_id, name, baudrate=None, parity=None, timeout=None, ctx=None, trace_func=None, max_count=REQ_COUNT_MAX):
-        self.slave_id = slave_id
-        self.name = name
-        self.client = None
-        self.ctx = ctx
-        self.trace_func = trace_func
-        self.max_count = max_count
+	def __init__(self, slave_id, name, baudrate=None, parity=None, timeout=None, ctx=None, trace_func=None, max_count=REQ_COUNT_MAX):
+		self.slave_id = slave_id
+		self.name = name
+		self.client = None
+		self.ctx = ctx
+		self.trace_func = trace_func
+		self.max_count = max_count
 
-        self.client = modbus_rtu_client(name, baudrate, parity)
-        if self.client is None:
-            raise ModbusClientError('No modbus rtu client set for device')
-        self.client.add_device(self.slave_id, self)
+		self.client = modbus_rtu_client(name, baudrate, parity)
+		if self.client is None:
+			raise ModbusClientError('No modbus rtu client set for device')
+		self.client.add_device(self.slave_id, self)
 
-        if timeout is not None and self.client.serial is not None:
-            self.client.serial.timeout = timeout
-            self.client.serial.writeTimeout = timeout
+		if timeout is not None and self.client.serial is not None:
+			self.client.serial.timeout = timeout
+			self.client.serial.writeTimeout = timeout
 
-    def close(self):
+	def close(self):
 
-        if self.client:
-            self.client.remove_device(self.slave_id)
+		if self.client:
+			self.client.remove_device(self.slave_id)
 
-    def read(self, addr, count, op=FUNC_READ_HOLDING):
+	def read(self, addr, count, op=FUNC_READ_HOLDING):
 
-        return self.client.read(self.slave_id, addr, count, op=op, trace_func=self.trace_func, max_count=self.max_count)
+		return self.client.read(self.slave_id, addr, count, op=op, trace_func=self.trace_func, max_count=self.max_count)
 
-    def write(self, addr, data):
+	def write(self, addr, data):
 
-        return self.client.write(self.slave_id, addr, data, trace_func=self.trace_func, max_count=self.max_count)
+		return self.client.write(self.slave_id, addr, data, trace_func=self.trace_func, max_count=self.max_count)
 
 TCP_HDR_LEN = 6
 TCP_RESP_MIN_LEN = 3
@@ -336,284 +336,284 @@ TCP_DEFAULT_TIMEOUT = 2
 
 class ModbusClientDeviceTCP(object):
 
-    def __init__(self, slave_id, ipaddr, ipport=502, timeout=None, ctx=None, trace_func=None, max_count=REQ_COUNT_MAX, test=False):
-        self.slave_id = slave_id
-        self.ipaddr = ipaddr
-        self.ipport = ipport
-        self.timeout = timeout
-        self.ctx = ctx
-        self.socket = None
-        self.trace_func = trace_func
-        self.max_count = max_count
-
-        if ipport is None:
-            self.ipport = TCP_DEFAULT_PORT
-        if timeout is None:
-            self.timeout = TCP_DEFAULT_TIMEOUT
-
-        if test:
-            import sunspec.core.test.fake.socket as fake
-            self.socket = fake.socket()
-
-    def close(self):
-
-        self.disconnect()
-
-    def connect(self, timeout=None):
-
-        if self.socket:
-            self.disconnect()
-
-        if timeout is None:
-            timeout = self.timeout
-
-        try:
-            self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-            self.socket.settimeout(timeout)
-            self.socket.connect((self.ipaddr, self.ipport))
-        except Exception, e:
-            raise ModbusClientError('Connection error: %s' % str(e))
-
-    def disconnect(self):
-
-        try:
-            if self.socket:
-                self.socket.close()
-            self.socket = None
-        except Exception:
-            pass
-
-    def _read(self, addr, count, op=FUNC_READ_HOLDING):
-
-        resp = ''
-        len_remaining = TCP_HDR_LEN + TCP_RESP_MIN_LEN
-        len_found = False
-        except_code = None
-
-        req = struct.pack('>HHHBBHH', 0, 0, TCP_READ_REQ_LEN, int(self.slave_id), op, int(addr), int(count))
-
-        if self.trace_func:
-            s = '%s:%s:%s[addr=%s] ->' % (self.ipaddr, str(self.ipport), str(self.slave_id), addr)
-            for c in req:
-                s += '%02X' % (ord(c))
-            self.trace_func(s)
-
-        try:
-            self.socket.sendall(req)
-        except Exception, e:
-            raise ModbusClientError('Socket write error: %s' % str(e))
-
-        while len_remaining > 0:
-            c = self.socket.recv(len_remaining)
-            # print 'c = {0}'.format(c)
-            len_read = len(c);
-            if len_read > 0:
-                resp += c
-                len_remaining -= len_read
-                if len_found is False and len(resp) >= TCP_HDR_LEN + TCP_RESP_MIN_LEN:
-                    data_len = struct.unpack('>H', resp[TCP_HDR_O_LEN:TCP_HDR_O_LEN + 2])
-                    len_remaining = data_len[0] - (len(resp) - TCP_HDR_LEN)
-            else:
-                raise ModbusClientError('Response timeout')
-
-        if not (ord(resp[TCP_HDR_LEN + 1]) & 0x80):
-            len_remaining = (ord(resp[TCP_HDR_LEN + 2]) + TCP_HDR_LEN) - len(resp)
-            len_found = True
-        else:
-            except_code = ord(resp[TCP_HDR_LEN + 2])
-
-        if self.trace_func:
-            s = '%s:%s:%s[addr=%s] <--' % (self.ipaddr, str(self.ipport), str(self.slave_id), addr)
-            for c in resp:
-                s += '%02X' % (ord(c))
-            self.trace_func(s)
-
-        if except_code:
-            raise ModbusClientException('Modbus exception %d' % (except_code))
-
-        return resp[(TCP_HDR_LEN + 3):]
-
-    def read(self, addr, count, op=FUNC_READ_HOLDING):
-
-        resp = ''
-        read_count = 0
-        read_offset = 0
-        local_connect = False
-
-        if self.socket is None:
-            local_connect = True
-            self.connect(self.timeout)
-
-        try:
-            while (count > 0):
-                if count > self.max_count:
-                    read_count = self.max_count
-                else:
-                    read_count = count
-                data = self._read(addr + read_offset, read_count, op=op)
-                if data:
-                    resp += data
-                    count -= read_count
-                    read_offset += read_count
-                else:
-                    break
-        finally:
-            if local_connect:
-                self.disconnect()
-
-        return resp
-
-    def _write(self, addr, data):
-
-        resp = ''
-        len_remaining = TCP_HDR_LEN + TCP_RESP_MIN_LEN
-        len_found = False
-        except_code = None
-        func = FUNC_WRITE_MULTIPLE
-
-        write_len = len(data)
-        write_count = write_len/2
-        req = struct.pack('>HHHBBHHB', 0, 0, TCP_WRITE_MULT_REQ_LEN + write_len, int(self.slave_id), func, int(addr), write_count, write_len)
-        req += data
-
-        if self.trace_func:
-            s = '%s:%s:%s[addr=%s] ->' % (self.ipaddr, str(self.ipport), str(self.slave_id), addr)
-            for c in req:
-                s += '%02X' % (ord(c))
-            self.trace_func(s)
-
-        try:
-            self.socket.sendall(req)
-        except Exception, e:
-            raise ModbusClientError('Socket write error: %s' % str(e))
-
-        while len_remaining > 0:
-            c = self.socket.recv(len_remaining)
-            # print 'c = {0}'.format(c)
-            len_read = len(c);
-            if len_read > 0:
-                resp += c
-                len_remaining -= len_read
-                if len_found is False and len(resp) >= TCP_HDR_LEN + TCP_RESP_MIN_LEN:
-                    data_len = struct.unpack('>H', resp[TCP_HDR_O_LEN:TCP_HDR_O_LEN + 2])
-                    len_remaining = data_len[0] - (len(resp) - TCP_HDR_LEN)
-            else:
-                raise ModbusClientTimeout('Response timeout')
-
-        if not (ord(resp[TCP_HDR_LEN + 1]) & 0x80):
-            len_remaining = (ord(resp[TCP_HDR_LEN + 2]) + TCP_HDR_LEN) - len(resp)
-            len_found = True
-        else:
-            except_code = ord(resp[TCP_HDR_LEN + 2])
-
-        if self.trace_func:
-            s = '%s:%s:%s[addr=%s] <--' % (self.ipaddr, str(self.ipport), str(self.slave_id), addr)
-            for c in resp:
-                s += '%02X' % (ord(c))
-            self.trace_func(s)
-
-        if except_code:
-            raise ModbusClientException('Modbus exception: %d' % (except_code))
-
-    def write(self, addr, data):
-
-        write_count = 0
-        write_offset = 0
-        local_connect = False
-        count = len(data)/2
-
-        if self.socket is None:
-            local_connect = True
-            self.connect(self.timeout)
-
-        try:
-            while (count > 0):
-                if count > self.max_count:
-                    write_count = self.max_count
-                else:
-                    write_count = count
-                self._write(addr + write_offset, data[(write_offset * 2):((write_offset + write_count) * 2)])
-                count -= write_count
-                write_offset += write_count
-        finally:
-            if local_connect:
-                self.disconnect()
+	def __init__(self, slave_id, ipaddr, ipport=502, timeout=None, ctx=None, trace_func=None, max_count=REQ_COUNT_MAX, test=False):
+		self.slave_id = slave_id
+		self.ipaddr = ipaddr
+		self.ipport = ipport
+		self.timeout = timeout
+		self.ctx = ctx
+		self.socket = None
+		self.trace_func = trace_func
+		self.max_count = max_count
+
+		if ipport is None:
+			self.ipport = TCP_DEFAULT_PORT
+		if timeout is None:
+			self.timeout = TCP_DEFAULT_TIMEOUT
+
+		if test:
+			import sunspec.core.test.fake.socket as fake
+			self.socket = fake.socket()
+
+	def close(self):
+
+		self.disconnect()
+
+	def connect(self, timeout=None):
+
+		if self.socket:
+			self.disconnect()
+
+		if timeout is None:
+			timeout = self.timeout
+
+		try:
+			self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+			self.socket.settimeout(timeout)
+			self.socket.connect((self.ipaddr, self.ipport))
+		except Exception as e:
+			raise ModbusClientError('Connection error: %s' % str(e))
+
+	def disconnect(self):
+
+		try:
+			if self.socket:
+				self.socket.close()
+			self.socket = None
+		except Exception:
+			pass
+
+	def _read(self, addr, count, op=FUNC_READ_HOLDING):
+
+		resp = ''
+		len_remaining = TCP_HDR_LEN + TCP_RESP_MIN_LEN
+		len_found = False
+		except_code = None
+
+		req = struct.pack('>HHHBBHH', 0, 0, TCP_READ_REQ_LEN, int(self.slave_id), op, int(addr), int(count))
+
+		if self.trace_func:
+			s = '%s:%s:%s[addr=%s] ->' % (self.ipaddr, str(self.ipport), str(self.slave_id), addr)
+			for c in req:
+				s += '%02X' % (ord(c))
+			self.trace_func(s)
+
+		try:
+			self.socket.sendall(req)
+		except Exception as e:
+			raise ModbusClientError('Socket write error: %s' % str(e))
+
+		while len_remaining > 0:
+			c = self.socket.recv(len_remaining)
+			# print 'c = {0}'.format(c)
+			len_read = len(c);
+			if len_read > 0:
+				resp += c
+				len_remaining -= len_read
+				if len_found is False and len(resp) >= TCP_HDR_LEN + TCP_RESP_MIN_LEN:
+					data_len = struct.unpack('>H', resp[TCP_HDR_O_LEN:TCP_HDR_O_LEN + 2])
+					len_remaining = data_len[0] - (len(resp) - TCP_HDR_LEN)
+			else:
+				raise ModbusClientError('Response timeout')
+
+		if not (ord(resp[TCP_HDR_LEN + 1]) & 0x80):
+			len_remaining = (ord(resp[TCP_HDR_LEN + 2]) + TCP_HDR_LEN) - len(resp)
+			len_found = True
+		else:
+			except_code = ord(resp[TCP_HDR_LEN + 2])
+
+		if self.trace_func:
+			s = '%s:%s:%s[addr=%s] <--' % (self.ipaddr, str(self.ipport), str(self.slave_id), addr)
+			for c in resp:
+				s += '%02X' % (ord(c))
+			self.trace_func(s)
+
+		if except_code:
+			raise ModbusClientException('Modbus exception %d' % (except_code))
+
+		return resp[(TCP_HDR_LEN + 3):]
+
+	def read(self, addr, count, op=FUNC_READ_HOLDING):
+
+		resp = ''
+		read_count = 0
+		read_offset = 0
+		local_connect = False
+
+		if self.socket is None:
+			local_connect = True
+			self.connect(self.timeout)
+
+		try:
+			while (count > 0):
+				if count > self.max_count:
+					read_count = self.max_count
+				else:
+					read_count = count
+				data = self._read(addr + read_offset, read_count, op=op)
+				if data:
+					resp += data
+					count -= read_count
+					read_offset += read_count
+				else:
+					break
+		finally:
+			if local_connect:
+				self.disconnect()
+
+		return resp
+
+	def _write(self, addr, data):
+
+		resp = ''
+		len_remaining = TCP_HDR_LEN + TCP_RESP_MIN_LEN
+		len_found = False
+		except_code = None
+		func = FUNC_WRITE_MULTIPLE
+
+		write_len = len(data)
+		write_count = write_len/2
+		req = struct.pack('>HHHBBHHB', 0, 0, TCP_WRITE_MULT_REQ_LEN + write_len, int(self.slave_id), func, int(addr), write_count, write_len)
+		req += data
+
+		if self.trace_func:
+			s = '%s:%s:%s[addr=%s] ->' % (self.ipaddr, str(self.ipport), str(self.slave_id), addr)
+			for c in req:
+				s += '%02X' % (ord(c))
+			self.trace_func(s)
+
+		try:
+			self.socket.sendall(req)
+		except Exception as e:
+			raise ModbusClientError('Socket write error: %s' % str(e))
+
+		while len_remaining > 0:
+			c = self.socket.recv(len_remaining)
+			# print 'c = {0}'.format(c)
+			len_read = len(c);
+			if len_read > 0:
+				resp += c
+				len_remaining -= len_read
+				if len_found is False and len(resp) >= TCP_HDR_LEN + TCP_RESP_MIN_LEN:
+					data_len = struct.unpack('>H', resp[TCP_HDR_O_LEN:TCP_HDR_O_LEN + 2])
+					len_remaining = data_len[0] - (len(resp) - TCP_HDR_LEN)
+			else:
+				raise ModbusClientTimeout('Response timeout')
+
+		if not (ord(resp[TCP_HDR_LEN + 1]) & 0x80):
+			len_remaining = (ord(resp[TCP_HDR_LEN + 2]) + TCP_HDR_LEN) - len(resp)
+			len_found = True
+		else:
+			except_code = ord(resp[TCP_HDR_LEN + 2])
+
+		if self.trace_func:
+			s = '%s:%s:%s[addr=%s] <--' % (self.ipaddr, str(self.ipport), str(self.slave_id), addr)
+			for c in resp:
+				s += '%02X' % (ord(c))
+			self.trace_func(s)
+
+		if except_code:
+			raise ModbusClientException('Modbus exception: %d' % (except_code))
+
+	def write(self, addr, data):
+
+		write_count = 0
+		write_offset = 0
+		local_connect = False
+		count = len(data)/2
+
+		if self.socket is None:
+			local_connect = True
+			self.connect(self.timeout)
+
+		try:
+			while (count > 0):
+				if count > self.max_count:
+					write_count = self.max_count
+				else:
+					write_count = count
+				self._write(addr + write_offset, data[(write_offset * 2):((write_offset + write_count) * 2)])
+				count -= write_count
+				write_offset += write_count
+		finally:
+			if local_connect:
+				self.disconnect()
 
 class ModbusClientDeviceMapped(object):
 
-    def __init__(self, slave_id, name, pathlist=None, max_count=None, ctx=None):
+	def __init__(self, slave_id, name, pathlist=None, max_count=None, ctx=None):
 
-        self.slave_id = slave_id
-        self.name = name
-        self.ctx = ctx
-        self.modbus_map = None
+		self.slave_id = slave_id
+		self.name = name
+		self.ctx = ctx
+		self.modbus_map = None
 
-        if name is not None:
-            self.modbus_map = mbmap.ModbusMap(slave_id)
-            self.modbus_map.from_xml(name, pathlist)
-        else:
-            raise mbmap.ModbusMapError('No modbus map file provided during initialization')
+		if name is not None:
+			self.modbus_map = mbmap.ModbusMap(slave_id)
+			self.modbus_map.from_xml(name, pathlist)
+		else:
+			raise mbmap.ModbusMapError('No modbus map file provided during initialization')
 
-    def close(self):
+	def close(self):
 
-        pass
+		pass
 
-    def read(self, addr, count, op=None):
+	def read(self, addr, count, op=None):
 
-        if self.modbus_map is not None:
-            return self.modbus_map.read(addr, count, op)
-        else:
-            raise ModbusClientError('No modbus map set for device')
+		if self.modbus_map is not None:
+			return self.modbus_map.read(addr, count, op)
+		else:
+			raise ModbusClientError('No modbus map set for device')
 
-    def write(self, addr, data):
+	def write(self, addr, data):
 
-        if self.modbus_map is not None:
-            return self.modbus_map.write(addr, data)
-        else:
-            raise ModbusClientError('No modbus map set for device')
+		if self.modbus_map is not None:
+			return self.modbus_map.write(addr, data)
+		else:
+			raise ModbusClientError('No modbus map set for device')
 
 def __generate_crc16_table():
-    ''' Generates a crc16 lookup table
-
-    .. note:: This will only be generated once
-    '''
-    result = []
-    for byte in range(256):
-        crc = 0x0000
-        for bit in range(8):
-            if (byte ^ crc) & 0x0001:
-                crc = (crc >> 1) ^ 0xa001
-            else: crc >>= 1
-            byte >>= 1
-        result.append(crc)
-    return result
+	''' Generates a crc16 lookup table
+
+	.. note:: This will only be generated once
+	'''
+	result = []
+	for byte in range(256):
+		crc = 0x0000
+		for bit in range(8):
+			if (byte ^ crc) & 0x0001:
+				crc = (crc >> 1) ^ 0xa001
+			else: crc >>= 1
+			byte >>= 1
+		result.append(crc)
+	return result
 
 __crc16_table = __generate_crc16_table()
 
 def computeCRC(data):
-    ''' Computes a crc16 on the passed in string. For modbus,
-    this is only used on the binary serial protocols (in this
-    case RTU).
-
-    The difference between modbus's crc16 and a normal crc16
-    is that modbus starts the crc value out at 0xffff.
-
-    :param data: The data to create a crc16 of
-    :returns: The calculated CRC
-    '''
-    crc = 0xffff
-    for a in data:
-        idx = __crc16_table[(crc ^ ord(a)) & 0xff];
-        crc = ((crc >> 8) & 0xff) ^ idx
-    swapped = ((crc << 8) & 0xff00) | ((crc >> 8) & 0x00ff)
-    return swapped
+	''' Computes a crc16 on the passed in string. For modbus,
+	this is only used on the binary serial protocols (in this
+	case RTU).
+
+	The difference between modbus's crc16 and a normal crc16
+	is that modbus starts the crc value out at 0xffff.
+
+	:param data: The data to create a crc16 of
+	:returns: The calculated CRC
+	'''
+	crc = 0xffff
+	for a in data:
+		idx = __crc16_table[(crc ^ ord(a)) & 0xff];
+		crc = ((crc >> 8) & 0xff) ^ idx
+	swapped = ((crc << 8) & 0xff00) | ((crc >> 8) & 0x00ff)
+	return swapped
 
 def checkCRC(data, check):
-    ''' Checks if the data matches the passed in CRC
+	''' Checks if the data matches the passed in CRC
 
-    :param data: The data to create a crc16 of
-    :param check: The CRC to validate
-    :returns: True if matched, False otherwise
-    '''
-    return computeCRC(data) == check
+	:param data: The data to create a crc16 of
+	:param check: The CRC to validate
+	:returns: True if matched, False otherwise
+	'''
+	return computeCRC(data) == check
 
diff --git a/sunspec/core/modbus/mbmap.py b/sunspec/core/modbus/mbmap.py
index 481a8b2..2ebf45c 100644
--- a/sunspec/core/modbus/mbmap.py
+++ b/sunspec/core/modbus/mbmap.py
@@ -1,32 +1,32 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2017 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import struct
 
 try:
-    import xml.etree.ElementTree as ET
+	import xml.etree.ElementTree as ET
 except:
-    import elementtree.ElementTree as ET
+	import elementtree.ElementTree as ET
 
 MBMAP_ROOT = 'mbmap'
 MBMAP_ADDR = 'addr'
@@ -62,379 +62,379 @@ func_value = {MBMAP_FUNC_INPUT: 4, MBMAP_FUNC_HOLDING: 3}
 func_name = {4: MBMAP_FUNC_INPUT, 3: MBMAP_FUNC_HOLDING}
 
 class ModbusMapError(Exception):
-    pass
+	pass
 
 class ModbusMap(object):
 
-    def __init__(self, slave_id=None, func=MBMAP_FUNC_HOLDING, base_addr=MBMAP_BASE_ADDR_DEFAULT, ns=None, lid=None,
-                 mapid=None, time=None):
-
-        self.slave_id = slave_id
-        self.base_addr = base_addr
-        self.ns = ns
-        self.lid = lid
-        self.mapid = mapid
-        self.time = time
-        self.regs = []
-
-        value = func_value.get(func)
-        if value is None:
-            raise ModbusMapError('Unsupported function: %s' % (func))
-        self.func = value
-
-
-    def from_hex(self, name, pathlist=None):
-
-        data = None
-        offset = 0
-        try:
-            f = open(name, 'r')
-            for line in f:
-                if line[0] != '#':
-                    data_list = line.rstrip('\r\n').split()
-                    data_len = len(data_list)/2
-                    if data_len > 0:
-                        # print offset, data_list
-                        for b in data_list:
-                            c = struct.pack('B', int(b, 16))
-                            if data is None:
-                                data = c
-                            else:
-                                data += c
-
-            mmr = ModbusMapRegs(offset, len(data)/2, data, MBMAP_REGS_ACCESS_RW)
-            self.regs.append(mmr)
-            f.close()
-        except Exception, e:
-            try:
-                f.close()
-            except:
-                pass
-            raise ModbusMapError('Error loading map file: %s' % str(e))
-
-    def from_xml(self, filename=None, pathlist=None, element=None):
-
-        offset = 0
-        next_offset = offset
-
-        try:
-            if filename is not None:
-                if pathlist is not None:
-                    map_data = pathlist.read(filename)
-                else:
-                    f = open(filename, 'r')
-                    map_data = f.read()
-                    f.close()
-
-                root = ET.fromstring(map_data)
-            elif element is not None:
-                root = element
-            else:
-                raise ModbusMapError('Root element not provided')
-
-            func = root.attrib.get(MBMAP_FUNC, MBMAP_FUNC_HOLDING)
-            value = func_value.get(func)
-            if value is None:
-                raise ModbusMapError('Unsupported function: %s' % (func))
-            self.func = value
-            self.base_addr = root.attrib.get(MBMAP_ADDR, 40000)
-            self.ns = root.attrib.get(MBMAP_NS)
-            self.lid = root.attrib.get(MBMAP_LID)
-            self.mapid = root.attrib.get(MBMAP_MAPID)
-            self.time = root.attrib.get(MBMAP_TIME)
-
-            for r in root.findall(MBMAP_REGS):
-                offset = r.attrib.get(MBMAP_REGS_OFFSET)
-                if offset is None:
-                    offset = next_offset
-                else:
-                    offset = int(offset)
-                rlen = int(r.attrib.get(MBMAP_REGS_LEN, 0))
-                rtype = r.attrib.get(MBMAP_REGS_TYPE, MBMAP_REGS_TYPE_HEX_STRING)
-                access = r.attrib.get(MBMAP_REGS_ACCESS, MBMAP_REGS_ACCESS_R)
-                fill = r.attrib.get(MBMAP_REGS_FILL, '\0')
-                text = r.text
-
-                if len(self.regs) > 0:
-                    last_regs = self.regs[-1]
-                    last_regs_next = last_regs.offset + last_regs.count
-                else:
-                    last_regs = None
-                    last_regs_next = 0
-
-                if offset < last_regs_next:
-                    raise ModbusMapError('Register offsets must be in ascending order with no overlap %d  %d' % (offset, last_regs_next))
-
-                data = None
-
-                if not text:
-                    if rtype ==  MBMAP_REGS_TYPE_STRING or rtype == MBMAP_REGS_TYPE_HEX_STRING:
-                        text = ''
-                    else:
-                        text = '0'
-
-                if rtype == MBMAP_REGS_TYPE_S16:
-                    data = struct.pack('>h', int(text, 0))
-                    rlen = 1
-                elif rtype == MBMAP_REGS_TYPE_U16:
-                    data = struct.pack('>H', int(text, 0))
-                    rlen = 1
-                elif rtype == MBMAP_REGS_TYPE_S32:
-                    data = struct.pack('>l', int(text, 0))
-                    rlen = 2
-                elif rtype == MBMAP_REGS_TYPE_U32:
-                    data = struct.pack('>L', long(text, 0))
-                    rlen = 2
-                elif rtype == MBMAP_REGS_TYPE_S64:
-                    data = struct.pack('>q', long(text, 0))
-                    rlen = 4
-                elif rtype == MBMAP_REGS_TYPE_U64:
-                    data = struct.pack('>Q', long(text, 0))
-                    rlen = 4
-                elif rtype == MBMAP_REGS_TYPE_F32:
-                    data = struct.pack('>f', float(text))
-                    rlen = 2
-                elif rtype == MBMAP_REGS_TYPE_F64:
-                    data = struct.pack('>d', float(text))
-                    rlen = 4
-                elif rtype == MBMAP_REGS_TYPE_STRING:
-                    if rlen == 0:
-                        rlen = (len(text) + 3)/4
-                    data = struct.pack(str(rlen * 2) + 's', str(text))
-                elif rtype == MBMAP_REGS_TYPE_HEX_STRING:
-                    if text:
-                        # remove any spaces
-                        text = text.replace(' ','')
-                    text_len = len(text)
-                    if text_len % 4 != 0:
-                        raise ModbusMapError('Hex string content length must be a multiple of 4 bytes')
-                    if rlen == 0:
-                        rlen = text_len/4
-                    text_index = 0
-                    while text_index < text_len:
-                        c = struct.pack('B', int(text[text_index:text_index + 2], 16))
-                        text_index += 2
-                        if data is None:
-                            data = c
-                        else:
-                            data += c
-                    # fill remainder of string with nulls
-                    regs_len = rlen * 2
-                    if regs_len > text_len:
-                        if data is None:
-                            data = ''
-                        data += struct.pack(str(regs_len - text_len) + 's', '')
-                else:
-                    raise ModbusMapError('Unknown type at offset %d' % (offset))
-
-                next_offset = offset + rlen
-
-                # if not contiguous, create a new register block
-                if last_regs is None or offset > last_regs_next:
-                    mmr = ModbusMapRegs(offset, rlen, data, access)
-                    self.regs.append(mmr)
-                # append to last register block
-                else:
-                    last_regs.append(offset, rlen, data, access)
-
-        except Exception, e:
-            raise ModbusMapError('Error loading %s (%s) at offset %d - %s' % (filename, pathlist, offset, str(e)))
-
-    def to_xml(self, parent=None, no_data=False):
-
-        attr = {}
-        attr[MBMAP_ADDR] = str(self.base_addr)
-        attr[MBMAP_FUNC] =  func_name.get(self.func, MBMAP_FUNC_HOLDING)
-        if self.ns is not None:
-            attr[MBMAP_NS] = str(self.ns)
-        if self.lid is not None:
-            attr[MBMAP_LID] = str(self.lid)
-        if self.mapid is not None:
-            attr[MBMAP_MAPID] = str(self.mapid)
-        if self.time is not None:
-            attr[MBMAP_TIME] = str(self.time)
+	def __init__(self, slave_id=None, func=MBMAP_FUNC_HOLDING, base_addr=MBMAP_BASE_ADDR_DEFAULT, ns=None, lid=None,
+				 mapid=None, time=None):
+
+		self.slave_id = slave_id
+		self.base_addr = base_addr
+		self.ns = ns
+		self.lid = lid
+		self.mapid = mapid
+		self.time = time
+		self.regs = []
+
+		value = func_value.get(func)
+		if value is None:
+			raise ModbusMapError('Unsupported function: %s' % (func))
+		self.func = value
+
+
+	def from_hex(self, name, pathlist=None):
+
+		data = None
+		offset = 0
+		try:
+			f = open(name, 'r')
+			for line in f:
+				if line[0] != '#':
+					data_list = line.rstrip('\r\n').split()
+					data_len = len(data_list)/2
+					if data_len > 0:
+						# print offset, data_list
+						for b in data_list:
+							c = struct.pack('B', int(b, 16))
+							if data is None:
+								data = c
+							else:
+								data += c
+
+			mmr = ModbusMapRegs(offset, len(data)/2, data, MBMAP_REGS_ACCESS_RW)
+			self.regs.append(mmr)
+			f.close()
+		except Exception as e:
+			try:
+				f.close()
+			except:
+				pass
+			raise ModbusMapError('Error loading map file: %s' % str(e))
+
+	def from_xml(self, filename=None, pathlist=None, element=None):
+
+		offset = 0
+		next_offset = offset
+
+		try:
+			if filename is not None:
+				if pathlist is not None:
+					map_data = pathlist.read(filename)
+				else:
+					f = open(filename, 'r')
+					map_data = f.read()
+					f.close()
+
+				root = ET.fromstring(map_data)
+			elif element is not None:
+				root = element
+			else:
+				raise ModbusMapError('Root element not provided')
+
+			func = root.attrib.get(MBMAP_FUNC, MBMAP_FUNC_HOLDING)
+			value = func_value.get(func)
+			if value is None:
+				raise ModbusMapError('Unsupported function: %s' % (func))
+			self.func = value
+			self.base_addr = root.attrib.get(MBMAP_ADDR, 40000)
+			self.ns = root.attrib.get(MBMAP_NS)
+			self.lid = root.attrib.get(MBMAP_LID)
+			self.mapid = root.attrib.get(MBMAP_MAPID)
+			self.time = root.attrib.get(MBMAP_TIME)
+
+			for r in root.findall(MBMAP_REGS):
+				offset = r.attrib.get(MBMAP_REGS_OFFSET)
+				if offset is None:
+					offset = next_offset
+				else:
+					offset = int(offset)
+				rlen = int(r.attrib.get(MBMAP_REGS_LEN, 0))
+				rtype = r.attrib.get(MBMAP_REGS_TYPE, MBMAP_REGS_TYPE_HEX_STRING)
+				access = r.attrib.get(MBMAP_REGS_ACCESS, MBMAP_REGS_ACCESS_R)
+				fill = r.attrib.get(MBMAP_REGS_FILL, '\0')
+				text = r.text
+
+				if len(self.regs) > 0:
+					last_regs = self.regs[-1]
+					last_regs_next = last_regs.offset + last_regs.count
+				else:
+					last_regs = None
+					last_regs_next = 0
+
+				if offset < last_regs_next:
+					raise ModbusMapError('Register offsets must be in ascending order with no overlap %d  %d' % (offset, last_regs_next))
+
+				data = None
+
+				if not text:
+					if rtype ==  MBMAP_REGS_TYPE_STRING or rtype == MBMAP_REGS_TYPE_HEX_STRING:
+						text = ''
+					else:
+						text = '0'
+
+				if rtype == MBMAP_REGS_TYPE_S16:
+					data = struct.pack('>h', int(text, 0))
+					rlen = 1
+				elif rtype == MBMAP_REGS_TYPE_U16:
+					data = struct.pack('>H', int(text, 0))
+					rlen = 1
+				elif rtype == MBMAP_REGS_TYPE_S32:
+					data = struct.pack('>l', int(text, 0))
+					rlen = 2
+				elif rtype == MBMAP_REGS_TYPE_U32:
+					data = struct.pack('>L', long(text, 0))
+					rlen = 2
+				elif rtype == MBMAP_REGS_TYPE_S64:
+					data = struct.pack('>q', long(text, 0))
+					rlen = 4
+				elif rtype == MBMAP_REGS_TYPE_U64:
+					data = struct.pack('>Q', long(text, 0))
+					rlen = 4
+				elif rtype == MBMAP_REGS_TYPE_F32:
+					data = struct.pack('>f', float(text))
+					rlen = 2
+				elif rtype == MBMAP_REGS_TYPE_F64:
+					data = struct.pack('>d', float(text))
+					rlen = 4
+				elif rtype == MBMAP_REGS_TYPE_STRING:
+					if rlen == 0:
+						rlen = (len(text) + 3)/4
+					data = struct.pack(str(rlen * 2) + 's', str(text))
+				elif rtype == MBMAP_REGS_TYPE_HEX_STRING:
+					if text:
+						# remove any spaces
+						text = text.replace(' ','')
+					text_len = len(text)
+					if text_len % 4 != 0:
+						raise ModbusMapError('Hex string content length must be a multiple of 4 bytes')
+					if rlen == 0:
+						rlen = text_len/4
+					text_index = 0
+					while text_index < text_len:
+						c = struct.pack('B', int(text[text_index:text_index + 2], 16))
+						text_index += 2
+						if data is None:
+							data = c
+						else:
+							data += c
+					# fill remainder of string with nulls
+					regs_len = rlen * 2
+					if regs_len > text_len:
+						if data is None:
+							data = ''
+						data += struct.pack(str(regs_len - text_len) + 's', '')
+				else:
+					raise ModbusMapError('Unknown type at offset %d' % (offset))
+
+				next_offset = offset + rlen
+
+				# if not contiguous, create a new register block
+				if last_regs is None or offset > last_regs_next:
+					mmr = ModbusMapRegs(offset, rlen, data, access)
+					self.regs.append(mmr)
+				# append to last register block
+				else:
+					last_regs.append(offset, rlen, data, access)
+
+		except Exception as e:
+			raise ModbusMapError('Error loading %s (%s) at offset %d - %s' % (filename, pathlist, offset, str(e)))
+
+	def to_xml(self, parent=None, no_data=False):
+
+		attr = {}
+		attr[MBMAP_ADDR] = str(self.base_addr)
+		attr[MBMAP_FUNC] =  func_name.get(self.func, MBMAP_FUNC_HOLDING)
+		if self.ns is not None:
+			attr[MBMAP_NS] = str(self.ns)
+		if self.lid is not None:
+			attr[MBMAP_LID] = str(self.lid)
+		if self.mapid is not None:
+			attr[MBMAP_MAPID] = str(self.mapid)
+		if self.time is not None:
+			attr[MBMAP_TIME] = str(self.time)
  
-        if parent is None:
-            element = ET.Element(MBMAP_ROOT, attrib=attr)
-        else:
-            element = ET.SubElement(parent, MBMAP_ROOT, attrib=attr)
-
-        for regs in self.regs:
-            e = ET.SubElement(element, MBMAP_REGS, attrib={MBMAP_REGS_OFFSET: str(regs.offset), MBMAP_REGS_LEN: str(regs.count)})
-
-            if no_data is False:
-                s = ''
-                for d in regs.data:
-                    s += '%02x' % ord(d)
-                e.text = s
-
-        return element
-
-    def regs_add(self, addr=None, offset=None, count=1, access=MBMAP_REGS_ACCESS_RW):
-
-        if addr is not None:
-            if addr < self.base_addr:
-                raise ModbusMapError('Address out of range')
-            offset = addr - self.base_addr
-
-        if len(self.regs) > 0:
-            last_regs = self.regs[-1]
-            last_regs_next = last_regs.offset + last_regs.count
-        else:
-            last_regs = None
-            last_regs_next = 0
-
-        if offset < last_regs_next:
-            raise ModbusMapError('Register offsets must be in ascending order with no overlap %d  %d' % (offset, last_regs_next))
-
-        data = struct.pack(str(count * 2) + 's', '')
-
-        if last_regs is None or offset > last_regs_next:
-            mmr = ModbusMapRegs(offset, count, data, access)
-            self.regs.append(mmr)
-        # append to last register block
-        else:
-            mmr = last_regs
-            last_regs.append(offset, count, data, access)
-
-        return mmr
-
-    def read(self, addr, count, op=None):
-
-        data = ''
-        count_remaining = count
-
-        if op and op != self.func:
-            raise ModbusMapError('Data read error - function mismatch: request func = %s map func = %s' % (str(op), str(self.func)))
-
-        offset = addr - int(self.base_addr)
-        for regs in self.regs:
-            if count_remaining > 0:
-                regs_end_offset = regs.offset + regs.count
-                if offset >= regs.offset and offset < regs_end_offset:
-                    read_count = regs_end_offset - offset
-                    if count_remaining < read_count:
-                        read_count = count_remaining
-                    data += regs.read(offset, read_count)
-                    offset += read_count
-                    count_remaining -= read_count
-                else:
-                    continue
-            else:
-                break
-
-        # must have all requested data for success
-        if len(data) != int(count) * 2:
-            print self
-            raise ModbusMapError('Data read error - addr = %d  data len = %d  count = %d' % (addr, len(data), count))
-
-        return data
-    
-    def write(self, addr, data):
-
-        data_len = len(data)
-        count_remaining = data_len/2
-
-        if data_len % 2 != 0:
-            raise ModbusMapError('Data length not even number of bytes - addr: %d  data len: %d' % (addr, data_len))
-
-        data_offset = 0
-        offset = addr - int(self.base_addr)
-        for regs in self.regs:
-            if count_remaining > 0:
-                regs_end_offset = regs.offset + regs.count
-                if offset >= regs.offset and offset < regs_end_offset:
-                    write_count = regs_end_offset - offset
-                    if count_remaining < write_count:
-                        write_count = count_remaining
-                    # regs
-                    # data += regs.read(offset, read_count)
-                    regs.write(offset, data[data_offset:data_offset+(write_count * 2)])
-                    offset += write_count
-                    data_offset += write_count
-                    count_remaining -= write_count
-                else:
-                    continue
-            else:
-                break
-
-        # must have written all data for success
-        if count_remaining > 0:
-           raise ModbusMapError('Data write error')
-
-    def not_equal(self, mbmap):
-
-        if self.base_addr != mbmap.base_addr:
-            return ('Base address mismatch: %s %s' % (str(self.base_addr), str(mbmap.base_addr)))
-        if self.func != mbmap.func:
-            return ('Function mismatch: %s %s' % (self.func, mbmap.func))
-
-        if len(self.regs) != len(mbmap.regs):
-            return ('Register group count mismatch')
-
-        for i in range(len(self.regs)):
-            not_equal = self.regs[i].not_equal(mbmap.regs[i])
-            if not_equal:
-                return not_equal
-        return False
-
-    def __str__(self):
-        s = 'modbus_map: slave id = %s func = %s base_addr = %s' % (self.slave_id, self.func, self.base_addr)
-        for regs in self.regs:
-            s += '\n' + str(regs)
-        return s
+		if parent is None:
+			element = ET.Element(MBMAP_ROOT, attrib=attr)
+		else:
+			element = ET.SubElement(parent, MBMAP_ROOT, attrib=attr)
+
+		for regs in self.regs:
+			e = ET.SubElement(element, MBMAP_REGS, attrib={MBMAP_REGS_OFFSET: str(regs.offset), MBMAP_REGS_LEN: str(regs.count)})
+
+			if no_data is False:
+				s = ''
+				for d in regs.data:
+					s += '%02x' % ord(d)
+				e.text = s
+
+		return element
+
+	def regs_add(self, addr=None, offset=None, count=1, access=MBMAP_REGS_ACCESS_RW):
+
+		if addr is not None:
+			if addr < self.base_addr:
+				raise ModbusMapError('Address out of range')
+			offset = addr - self.base_addr
+
+		if len(self.regs) > 0:
+			last_regs = self.regs[-1]
+			last_regs_next = last_regs.offset + last_regs.count
+		else:
+			last_regs = None
+			last_regs_next = 0
+
+		if offset < last_regs_next:
+			raise ModbusMapError('Register offsets must be in ascending order with no overlap %d  %d' % (offset, last_regs_next))
+
+		data = struct.pack(str(count * 2) + 's', '')
+
+		if last_regs is None or offset > last_regs_next:
+			mmr = ModbusMapRegs(offset, count, data, access)
+			self.regs.append(mmr)
+		# append to last register block
+		else:
+			mmr = last_regs
+			last_regs.append(offset, count, data, access)
+
+		return mmr
+
+	def read(self, addr, count, op=None):
+
+		data = ''
+		count_remaining = count
+
+		if op and op != self.func:
+			raise ModbusMapError('Data read error - function mismatch: request func = %s map func = %s' % (str(op), str(self.func)))
+
+		offset = addr - int(self.base_addr)
+		for regs in self.regs:
+			if count_remaining > 0:
+				regs_end_offset = regs.offset + regs.count
+				if offset >= regs.offset and offset < regs_end_offset:
+					read_count = regs_end_offset - offset
+					if count_remaining < read_count:
+						read_count = count_remaining
+					data += regs.read(offset, read_count)
+					offset += read_count
+					count_remaining -= read_count
+				else:
+					continue
+			else:
+				break
+
+		# must have all requested data for success
+		if len(data) != int(count) * 2:
+			print(self)
+			raise ModbusMapError('Data read error - addr = %d  data len = %d  count = %d' % (addr, len(data), count))
+
+		return data
+	
+	def write(self, addr, data):
+
+		data_len = len(data)
+		count_remaining = data_len/2
+
+		if data_len % 2 != 0:
+			raise ModbusMapError('Data length not even number of bytes - addr: %d  data len: %d' % (addr, data_len))
+
+		data_offset = 0
+		offset = addr - int(self.base_addr)
+		for regs in self.regs:
+			if count_remaining > 0:
+				regs_end_offset = regs.offset + regs.count
+				if offset >= regs.offset and offset < regs_end_offset:
+					write_count = regs_end_offset - offset
+					if count_remaining < write_count:
+						write_count = count_remaining
+					# regs
+					# data += regs.read(offset, read_count)
+					regs.write(offset, data[data_offset:data_offset+(write_count * 2)])
+					offset += write_count
+					data_offset += write_count
+					count_remaining -= write_count
+				else:
+					continue
+			else:
+				break
+
+		# must have written all data for success
+		if count_remaining > 0:
+		   raise ModbusMapError('Data write error')
+
+	def not_equal(self, mbmap):
+
+		if self.base_addr != mbmap.base_addr:
+			return ('Base address mismatch: %s %s' % (str(self.base_addr), str(mbmap.base_addr)))
+		if self.func != mbmap.func:
+			return ('Function mismatch: %s %s' % (self.func, mbmap.func))
+
+		if len(self.regs) != len(mbmap.regs):
+			return ('Register group count mismatch')
+
+		for i in range(len(self.regs)):
+			not_equal = self.regs[i].not_equal(mbmap.regs[i])
+			if not_equal:
+				return not_equal
+		return False
+
+	def __str__(self):
+		s = 'modbus_map: slave id = %s func = %s base_addr = %s' % (self.slave_id, self.func, self.base_addr)
+		for regs in self.regs:
+			s += '\n' + str(regs)
+		return s
 
 class ModbusMapRegs(object):
 
-    def __init__(self, offset, count, data, access=MBMAP_REGS_ACCESS_R):
-        self.offset = offset
-        self.count = count
-        self.data = data
-        self.access = access
-
-    def read(self, offset, count):
-        regs_end_offset = self.offset + self.count
-        end_offset = offset + count
-        read_count = count
-        if offset >= self.offset and offset < regs_end_offset:
-            if offset < regs_end_offset and end_offset > regs_end_offset:
-                read_count = regs_end_offset - offset
-            if read_count > 0:
-                start = (offset - self.offset) * 2
-                end = start + (read_count * 2)
-                return self.data[start:end]
-        else:
-            raise ModbusMapError('Data read error')
-
-    def write(self, offset, data):
-        count = len(data)/2
-        if (offset >= self.offset) and (offset + count <= self.offset + self.count):
-            start = (offset - self.offset) * 2
-            end = start + (count * 2)
-            self.data = self.data[:start] + data + self.data[end:]
-        else:
-           raise ModbusMapError('Data write error')
-
-    def append(self, offset, count, data, access=MBMAP_REGS_ACCESS_R):
-        self.data += data
-        self.count += count
-
-    def not_equal(self, regs):
-
-        if self.offset != regs.offset:
-            return ('Offset mismatch: %d %d' % (self.offset, regs.offset))
-        if self.count != regs.count:
-            return ('Count mismatch for offset %d: %d %d' % (self.offset, self.count, regs.count))
-        if self.data != regs.data:
-            for i in range(len(self.data)):
-                if self.data[i] != regs.data[i]:
-                    return ('Data mismatch at offset %d' % (self.offset + (i/2)))
-        if self.access != regs.access:
-            return ('Access mismatch for offset %d' % (self.offset))
-        return False
-
-    def __str__(self):
-        s = '  offset = %s count = %s access = %s' % (str(self.offset), str(self.count), str(self.access))
-        return s
+	def __init__(self, offset, count, data, access=MBMAP_REGS_ACCESS_R):
+		self.offset = offset
+		self.count = count
+		self.data = data
+		self.access = access
+
+	def read(self, offset, count):
+		regs_end_offset = self.offset + self.count
+		end_offset = offset + count
+		read_count = count
+		if offset >= self.offset and offset < regs_end_offset:
+			if offset < regs_end_offset and end_offset > regs_end_offset:
+				read_count = regs_end_offset - offset
+			if read_count > 0:
+				start = (offset - self.offset) * 2
+				end = start + (read_count * 2)
+				return self.data[start:end]
+		else:
+			raise ModbusMapError('Data read error')
+
+	def write(self, offset, data):
+		count = len(data)/2
+		if (offset >= self.offset) and (offset + count <= self.offset + self.count):
+			start = (offset - self.offset) * 2
+			end = start + (count * 2)
+			self.data = self.data[:start] + data + self.data[end:]
+		else:
+		   raise ModbusMapError('Data write error')
+
+	def append(self, offset, count, data, access=MBMAP_REGS_ACCESS_R):
+		self.data += data
+		self.count += count
+
+	def not_equal(self, regs):
+
+		if self.offset != regs.offset:
+			return ('Offset mismatch: %d %d' % (self.offset, regs.offset))
+		if self.count != regs.count:
+			return ('Count mismatch for offset %d: %d %d' % (self.offset, self.count, regs.count))
+		if self.data != regs.data:
+			for i in range(len(self.data)):
+				if self.data[i] != regs.data[i]:
+					return ('Data mismatch at offset %d' % (self.offset + (i/2)))
+		if self.access != regs.access:
+			return ('Access mismatch for offset %d' % (self.offset))
+		return False
+
+	def __str__(self):
+		s = '  offset = %s count = %s access = %s' % (str(self.offset), str(self.count), str(self.access))
+		return s
 
 
diff --git a/sunspec/core/pics.py b/sunspec/core/pics.py
index 4ac2d9a..d249841 100644
--- a/sunspec/core/pics.py
+++ b/sunspec/core/pics.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
+	Copyright (C) 2017 SunSpec Alliance
 
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
 
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
 
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sunspec.core.suns as suns
@@ -54,12 +54,12 @@ PICS_IMPLEMENTED_FALSE = 'false'
 PICS_IMPLEMENTED_TRUE = 'true'
 
 pics_access_types = {
-    PICS_ACCESS_R: suns.SUNS_ACCESS_R,
-    PICS_ACCESS_RW: suns.SUNS_ACCESS_RW
+	PICS_ACCESS_R: suns.SUNS_ACCESS_R,
+	PICS_ACCESS_RW: suns.SUNS_ACCESS_RW
 }
 
 # map PICS block types to SunSpec block types
 pics_block_types = {
-    PICS_TYPE_FIXED: suns.SUNS_BLOCK_FIXED,
-    PICS_TYPE_REPEATING: suns.SUNS_BLOCK_REPEATING
+	PICS_TYPE_FIXED: suns.SUNS_BLOCK_FIXED,
+	PICS_TYPE_REPEATING: suns.SUNS_BLOCK_REPEATING
 }
diff --git a/sunspec/core/smdx.py b/sunspec/core/smdx.py
index 1b01fed..23c777a 100644
--- a/sunspec/core/smdx.py
+++ b/sunspec/core/smdx.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2017 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sunspec.core.suns as suns
@@ -75,58 +75,58 @@ SMDX_MANDATORY_FALSE = 'false'
 SMDX_MANDATORY_TRUE = 'true'
 
 smdx_access_types = {
-    SMDX_ACCESS_R: suns.SUNS_ACCESS_R,
-    SMDX_ACCESS_RW: suns.SUNS_ACCESS_RW
+	SMDX_ACCESS_R: suns.SUNS_ACCESS_R,
+	SMDX_ACCESS_RW: suns.SUNS_ACCESS_RW
 }
 
 smdx_mandatory_types = {
-    SMDX_MANDATORY_FALSE: suns.SUNS_MANDATORY_FALSE,
-    SMDX_MANDATORY_TRUE: suns.SUNS_MANDATORY_TRUE
+	SMDX_MANDATORY_FALSE: suns.SUNS_MANDATORY_FALSE,
+	SMDX_MANDATORY_TRUE: suns.SUNS_MANDATORY_TRUE
 }
 
 # map SMDX block types to SunSpec block types
 smdx_block_types = {
-    SMDX_ATTR_TYPE_FIXED: suns.SUNS_BLOCK_FIXED,
-    SMDX_ATTR_TYPE_REPEATING: suns.SUNS_BLOCK_REPEATING
+	SMDX_ATTR_TYPE_FIXED: suns.SUNS_BLOCK_FIXED,
+	SMDX_ATTR_TYPE_REPEATING: suns.SUNS_BLOCK_REPEATING
 }
 
 # map SMDX point types to SunSpec point types
 smdx_point_types = {
-    SMDX_TYPE_INT16: suns.SUNS_TYPE_INT16,
-    SMDX_TYPE_UINT16: suns.SUNS_TYPE_UINT16,
-    SMDX_TYPE_COUNT: suns.SUNS_TYPE_COUNT,
-    SMDX_TYPE_ACC16: suns.SUNS_TYPE_ACC16,
-    SMDX_TYPE_ENUM16: suns.SUNS_TYPE_ENUM16,
-    SMDX_TYPE_BITFIELD16: suns.SUNS_TYPE_BITFIELD16,
-    SMDX_TYPE_PAD: suns.SUNS_TYPE_PAD,
-    SMDX_TYPE_INT32: suns.SUNS_TYPE_INT32,
-    SMDX_TYPE_UINT32: suns.SUNS_TYPE_UINT32,
-    SMDX_TYPE_ACC32: suns.SUNS_TYPE_ACC32,
-    SMDX_TYPE_ENUM32: suns.SUNS_TYPE_ENUM32,
-    SMDX_TYPE_BITFIELD32: suns.SUNS_TYPE_BITFIELD32,
-    SMDX_TYPE_IPADDR: suns.SUNS_TYPE_IPADDR,
-    SMDX_TYPE_INT64: suns.SUNS_TYPE_INT64,
-    SMDX_TYPE_UINT64: suns.SUNS_TYPE_UINT64,
-    SMDX_TYPE_ACC64: suns.SUNS_TYPE_ACC64,
-    SMDX_TYPE_IPV6ADDR: suns.SUNS_TYPE_IPV6ADDR,
-    SMDX_TYPE_FLOAT32: suns.SUNS_TYPE_FLOAT32,
-    SMDX_TYPE_STRING: suns.SUNS_TYPE_STRING,
-    SMDX_TYPE_SUNSSF: suns.SUNS_TYPE_SUNSSF,
-    SMDX_TYPE_EUI48: suns.SUNS_TYPE_EUI48
+	SMDX_TYPE_INT16: suns.SUNS_TYPE_INT16,
+	SMDX_TYPE_UINT16: suns.SUNS_TYPE_UINT16,
+	SMDX_TYPE_COUNT: suns.SUNS_TYPE_COUNT,
+	SMDX_TYPE_ACC16: suns.SUNS_TYPE_ACC16,
+	SMDX_TYPE_ENUM16: suns.SUNS_TYPE_ENUM16,
+	SMDX_TYPE_BITFIELD16: suns.SUNS_TYPE_BITFIELD16,
+	SMDX_TYPE_PAD: suns.SUNS_TYPE_PAD,
+	SMDX_TYPE_INT32: suns.SUNS_TYPE_INT32,
+	SMDX_TYPE_UINT32: suns.SUNS_TYPE_UINT32,
+	SMDX_TYPE_ACC32: suns.SUNS_TYPE_ACC32,
+	SMDX_TYPE_ENUM32: suns.SUNS_TYPE_ENUM32,
+	SMDX_TYPE_BITFIELD32: suns.SUNS_TYPE_BITFIELD32,
+	SMDX_TYPE_IPADDR: suns.SUNS_TYPE_IPADDR,
+	SMDX_TYPE_INT64: suns.SUNS_TYPE_INT64,
+	SMDX_TYPE_UINT64: suns.SUNS_TYPE_UINT64,
+	SMDX_TYPE_ACC64: suns.SUNS_TYPE_ACC64,
+	SMDX_TYPE_IPV6ADDR: suns.SUNS_TYPE_IPV6ADDR,
+	SMDX_TYPE_FLOAT32: suns.SUNS_TYPE_FLOAT32,
+	SMDX_TYPE_STRING: suns.SUNS_TYPE_STRING,
+	SMDX_TYPE_SUNSSF: suns.SUNS_TYPE_SUNSSF,
+	SMDX_TYPE_EUI48: suns.SUNS_TYPE_EUI48
 }
 
 def model_id_to_filename(model_id):
 
-    return 'smdx_%05d.xml' % (int(model_id))
+	return 'smdx_%05d.xml' % (int(model_id))
 
 def model_filename_to_id(filename):
 
-    model_id = None
+	model_id = None
 
-    if filename[0:5] == 'smdx_' and filename[-4:] == '.xml':
-        try:
-            model_id = int(filename[5:-4])
-        except Exception, e:
-            pass
+	if filename[0:5] == 'smdx_' and filename[-4:] == '.xml':
+		try:
+			model_id = int(filename[5:-4])
+		except Exception as e:
+			pass
 
-    return model_id
+	return model_id
diff --git a/sunspec/core/suns.py b/sunspec/core/suns.py
index e6d73bb..3eb9e33 100644
--- a/sunspec/core/suns.py
+++ b/sunspec/core/suns.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2017 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sunspec.core.util as util
@@ -80,108 +80,108 @@ SUNS_BLOCK_REPEATING = 'repeating'
 SUNS_END_MODEL_ID = 0xffff
 
 def suns_to_int(x):
-    try:
-        return int(x, 0)
-    except TypeError:
-        return int(x)
+	try:
+		return int(x, 0)
+	except TypeError:
+		return int(x)
 
 def suns_to_long(x):
-    try:
-        return long(x, 0)
-    except TypeError:
-        return long(x)
+	try:
+		return long(x, 0)
+	except TypeError:
+		return long(x)
 
 def suns_to_str(s):
-    return str(s)
+	return str(s)
 
 def suns_to_float(f):
-    try:
-        return float(f)
-    except ValueError:
-        return None
+	try:
+		return float(f)
+	except ValueError:
+		return None
 
 def suns_is_impl_int16(value):
-    return not value == SUNS_UNIMPL_INT16
+	return not value == SUNS_UNIMPL_INT16
 
 def suns_is_impl_uint16(value):
-    return not value == SUNS_UNIMPL_UINT16
+	return not value == SUNS_UNIMPL_UINT16
 
 def suns_is_impl_acc16(value):
-    return not value == SUNS_UNIMPL_ACC16
+	return not value == SUNS_UNIMPL_ACC16
 
 def suns_is_impl_enum16(value):
-    return not value == SUNS_UNIMPL_ENUM16
+	return not value == SUNS_UNIMPL_ENUM16
 
 def suns_is_impl_bitfield16(value):
-    return not value == SUNS_UNIMPL_BITFIELD16
+	return not value == SUNS_UNIMPL_BITFIELD16
 
 def suns_is_impl_int32(value):
-    return not value == SUNS_UNIMPL_INT32
+	return not value == SUNS_UNIMPL_INT32
 
 def suns_is_impl_uint32(value):
-    return not value == SUNS_UNIMPL_UINT32
+	return not value == SUNS_UNIMPL_UINT32
 
 def suns_is_impl_acc32(value):
-    return not value == SUNS_UNIMPL_ACC32
+	return not value == SUNS_UNIMPL_ACC32
 
 def suns_is_impl_enum32(value):
-    return not value == SUNS_UNIMPL_ENUM32
+	return not value == SUNS_UNIMPL_ENUM32
 
 def suns_is_impl_bitfield32(value):
-    return not value == SUNS_UNIMPL_BITFIELD32
+	return not value == SUNS_UNIMPL_BITFIELD32
 
 def suns_is_impl_ipaddr(value):
-    return not value == SUNS_UNIMPL_IPADDR
+	return not value == SUNS_UNIMPL_IPADDR
 
 def suns_is_impl_int64(value):
-    return not value == SUNS_UNIMPL_INT64
+	return not value == SUNS_UNIMPL_INT64
 
 def suns_is_impl_uint64(value):
-    return not value == SUNS_UNIMPL_UINT64
+	return not value == SUNS_UNIMPL_UINT64
 
 def suns_is_impl_acc64(value):
-    return not value == SUNS_UNIMPL_ACC64
+	return not value == SUNS_UNIMPL_ACC64
 
 def suns_is_impl_ipv6addr(value):
-    if value:
-        return not value[0] == '\0'
-    return False
+	if value:
+		return not value[0] == '\0'
+	return False
 
 def suns_is_impl_float32(value):
-    return (value == value) and (value != None)
+	return (value == value) and (value != None)
 
 def suns_is_impl_string(value):
-    if value:
-        return not value[0] == '\0'
-    return False
+	if value:
+		return not value[0] == '\0'
+	return False
 
 def suns_is_impl_sunssf(value):
-    return not value == SUNS_UNIMPL_SUNSSF
+	return not value == SUNS_UNIMPL_SUNSSF
 
 def suns_is_impl_eui48(value):
-    return not value == SUNS_UNIMPL_EUI48
+	return not value == SUNS_UNIMPL_EUI48
 
 # each entry contains: (len in registers, uniplemented value, data to value function, value to data function, to value function, default value)
 suns_point_type_info = {
-    SUNS_TYPE_INT16: (1, suns_is_impl_int16, util.data_to_s16, util.s16_to_data, suns_to_int, 0),
-    SUNS_TYPE_UINT16: (1, suns_is_impl_uint16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
-    SUNS_TYPE_COUNT: (1, suns_is_impl_uint16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
-    SUNS_TYPE_ACC16: (1, suns_is_impl_acc16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
-    SUNS_TYPE_ENUM16: (1, suns_is_impl_enum16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
-    SUNS_TYPE_BITFIELD16: (1, suns_is_impl_bitfield16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
-    SUNS_TYPE_PAD: (1, suns_is_impl_int16, util.data_to_s16, util.s16_to_data, suns_to_int, 0),
-    SUNS_TYPE_INT32: (2, suns_is_impl_int32, util.data_to_s32, util.s32_to_data, suns_to_int, 0),
-    SUNS_TYPE_UINT32: (2, suns_is_impl_uint32, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
-    SUNS_TYPE_ACC32: (2, suns_is_impl_acc32, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
-    SUNS_TYPE_ENUM32: (2, suns_is_impl_enum32, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
-    SUNS_TYPE_BITFIELD32: (2, suns_is_impl_bitfield32, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
-    SUNS_TYPE_IPADDR: (2, suns_is_impl_ipaddr, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
-    SUNS_TYPE_INT64: (4, suns_is_impl_int64, util.data_to_s64, util.s64_to_data, suns_to_long, 0),
-    SUNS_TYPE_UINT64: (4, suns_is_impl_uint64, util.data_to_s64, util.s64_to_data, suns_to_long, 0),
-    SUNS_TYPE_ACC64: (4, suns_is_impl_acc64, util.data_to_s64, util.s64_to_data, suns_to_long, 0),
-    SUNS_TYPE_IPV6ADDR: (8, suns_is_impl_ipv6addr, util.data_to_ipv6addr, util.ipv6addr_to_data, suns_to_str, 0),
-    SUNS_TYPE_FLOAT32: (2, suns_is_impl_float32, util.data_to_float, util.float_to_data32, suns_to_float, 0),
-    SUNS_TYPE_STRING: (None, suns_is_impl_string, util.data_to_str, util.str_to_data, suns_to_str, ''),
-    SUNS_TYPE_SUNSSF: (1, suns_is_impl_sunssf, util.data_to_s16, util.s16_to_data, suns_to_int, 0),
-    SUNS_TYPE_EUI48: (4, suns_is_impl_eui48, util.data_to_eui48, util.eui48_to_data, suns_to_str, 0)
+	SUNS_TYPE_INT16: (1, suns_is_impl_int16, util.data_to_s16, util.s16_to_data, suns_to_int, 0),
+	SUNS_TYPE_UINT16: (1, suns_is_impl_uint16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
+	SUNS_TYPE_COUNT: (1, suns_is_impl_uint16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
+	SUNS_TYPE_ACC16: (1, suns_is_impl_acc16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
+	SUNS_TYPE_ENUM16: (1, suns_is_impl_enum16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
+	SUNS_TYPE_BITFIELD16: (1, suns_is_impl_bitfield16, util.data_to_u16, util.u16_to_data, suns_to_int, 0),
+	SUNS_TYPE_PAD: (1, suns_is_impl_int16, util.data_to_s16, util.s16_to_data, suns_to_int, 0),
+	SUNS_TYPE_INT32: (2, suns_is_impl_int32, util.data_to_s32, util.s32_to_data, suns_to_int, 0),
+	SUNS_TYPE_UINT32: (2, suns_is_impl_uint32, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
+	SUNS_TYPE_ACC32: (2, suns_is_impl_acc32, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
+	SUNS_TYPE_ENUM32: (2, suns_is_impl_enum32, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
+	SUNS_TYPE_BITFIELD32: (2, suns_is_impl_bitfield32, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
+	SUNS_TYPE_IPADDR: (2, suns_is_impl_ipaddr, util.data_to_u32, util.u32_to_data, suns_to_long, 0),
+	SUNS_TYPE_INT64: (4, suns_is_impl_int64, util.data_to_s64, util.s64_to_data, suns_to_long, 0),
+	SUNS_TYPE_UINT64: (4, suns_is_impl_uint64, util.data_to_s64, util.s64_to_data, suns_to_long, 0),
+	SUNS_TYPE_ACC64: (4, suns_is_impl_acc64, util.data_to_s64, util.s64_to_data, suns_to_long, 0),
+	SUNS_TYPE_IPV6ADDR: (8, suns_is_impl_ipv6addr, util.data_to_ipv6addr, util.ipv6addr_to_data, suns_to_str, 0),
+	SUNS_TYPE_FLOAT32: (2, suns_is_impl_float32, util.data_to_float, util.float_to_data32, suns_to_float, 0),
+	SUNS_TYPE_STRING: (None, suns_is_impl_string, util.data_to_str, util.str_to_data, suns_to_str, ''),
+	SUNS_TYPE_SUNSSF: (1, suns_is_impl_sunssf, util.data_to_s16, util.s16_to_data, suns_to_int, 0),
+	SUNS_TYPE_EUI48: (4, suns_is_impl_eui48, util.data_to_eui48, util.eui48_to_data, suns_to_str, 0)
 }
diff --git a/sunspec/core/test/fake/serial.py b/sunspec/core/test/fake/serial.py
index d3ff8c9..e819d91 100644
--- a/sunspec/core/test/fake/serial.py
+++ b/sunspec/core/test/fake/serial.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2016 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2016 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 EIGHTBITS = 8
@@ -27,51 +27,51 @@ STOPBITS_ONE = 1
 
 class Serial(object):
 
-    def __init__(self, port=None, baudrate=9600, bytesize=EIGHTBITS, parity=PARITY_NONE, stopbits=STOPBITS_ONE,
-    	         timeout=None, xonxoff=False, rtscts=False, writeTimeout=None, dsrdtr=False, interCharTimeout=None):
-
-        self.test_serial = True
-        self.port = port
-        self.baudrate = baudrate
-        self.bytesize = bytesize
-        self.parity = parity
-        self.stopbits = stopbits
-        self.timeout = timeout
-        self.xonoff = xonxoff
-        self.rtscts = rtscts
-        self.writeTimeout = writeTimeout
-        self.dsrdtr = dsrdtr
-        self.interCharTimeout = interCharTimeout
-        self.is_open = False
-        self.in_buf = ''
-        self.out_buf = ''
-
-        self.open()
-
-    def open(self):
-    	self.is_open = True
-
-    def close(self):
-    	self.is_open = False
-
-    def read(self, size=1):
-        data = ''
-        read_len = size
-
-        data_len = len(self.in_buf)
-    	if data_len < read_len:
-    		read_len = data_len
-
-    	if read_len > 0:
-    		data = self.in_buf[:read_len]
-    		self.in_buf = self.in_buf[read_len:]
-    	return data
-
-    def write(self, data):
-    	self.out_buf += data
-
-    def flushInput(self):
-    	pass
-
-    def flushOutput(self):
-    	pass
+	def __init__(self, port=None, baudrate=9600, bytesize=EIGHTBITS, parity=PARITY_NONE, stopbits=STOPBITS_ONE,
+				 timeout=None, xonxoff=False, rtscts=False, writeTimeout=None, dsrdtr=False, interCharTimeout=None):
+
+		self.test_serial = True
+		self.port = port
+		self.baudrate = baudrate
+		self.bytesize = bytesize
+		self.parity = parity
+		self.stopbits = stopbits
+		self.timeout = timeout
+		self.xonoff = xonxoff
+		self.rtscts = rtscts
+		self.writeTimeout = writeTimeout
+		self.dsrdtr = dsrdtr
+		self.interCharTimeout = interCharTimeout
+		self.is_open = False
+		self.in_buf = ''
+		self.out_buf = ''
+
+		self.open()
+
+	def open(self):
+		self.is_open = True
+
+	def close(self):
+		self.is_open = False
+
+	def read(self, size=1):
+		data = ''
+		read_len = size
+
+		data_len = len(self.in_buf)
+		if data_len < read_len:
+			read_len = data_len
+
+		if read_len > 0:
+			data = self.in_buf[:read_len]
+			self.in_buf = self.in_buf[read_len:]
+		return data
+
+	def write(self, data):
+		self.out_buf += data
+
+	def flushInput(self):
+		pass
+
+	def flushOutput(self):
+		pass
diff --git a/sunspec/core/test/fake/socket.py b/sunspec/core/test/fake/socket.py
index 9a1437a..3cc0c0d 100644
--- a/sunspec/core/test/fake/socket.py
+++ b/sunspec/core/test/fake/socket.py
@@ -1,63 +1,63 @@
 
 """
-    Copyright (C) 2016 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2016 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 class socket(object):
 
-    def __init__(self, family=None, stype=None, proto=None):
+	def __init__(self, family=None, stype=None, proto=None):
 
-        self.test_socket = True
-        self.family = family
-        self.stype = stype
-        self.proto = proto
-        self.connected = False
-        self.timeout = 0
-        self.in_buf = ''
-        self.out_buf = ''
+		self.test_socket = True
+		self.family = family
+		self.stype = stype
+		self.proto = proto
+		self.connected = False
+		self.timeout = 0
+		self.in_buf = ''
+		self.out_buf = ''
 
-    def connect(self, addr_port):
-    	self.connected = True
+	def connect(self, addr_port):
+		self.connected = True
 
-    def settimeout(self, timeout):
-    	self.timeout = timeout
+	def settimeout(self, timeout):
+		self.timeout = timeout
 
-    def close(self):
-    	self.connected = False
+	def close(self):
+		self.connected = False
 
-    def recv(self, size):
-        data = ''
-        read_len = size
+	def recv(self, size):
+		data = ''
+		read_len = size
 
-        data_len = len(self.in_buf)
-    	if data_len < read_len:
-    		read_len = data_len
+		data_len = len(self.in_buf)
+		if data_len < read_len:
+			read_len = data_len
 
-    	if read_len > 0:
-    		data = self.in_buf[:read_len]
-    		self.in_buf = self.in_buf[read_len:]
-    	return data
+		if read_len > 0:
+			data = self.in_buf[:read_len]
+			self.in_buf = self.in_buf[read_len:]
+		return data
 
-    def send(self, data):
-    	self.out_buf += data
+	def send(self, data):
+		self.out_buf += data
 
-    def sendall(self, data):
-    	self.out_buf += data
+	def sendall(self, data):
+		self.out_buf += data
diff --git a/sunspec/core/test/test_all.py b/sunspec/core/test/test_all.py
index d5899f2..0e08513 100644
--- a/sunspec/core/test/test_all.py
+++ b/sunspec/core/test/test_all.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2016 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2016 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sys
@@ -26,49 +26,49 @@ import os
 import sunspec
 
 test_modules = [
-    'test_device',
-    'test_client',
-    'test_modbus_client',
-    'test_modbus_mbmap',
-    'test_data'
+	'test_device',
+	'test_client',
+	'test_modbus_client',
+	'test_modbus_mbmap',
+	'test_data'
 ]
 
 def test_all(pathlist=None, stop_on_failure=False, local=False):
 
-    total_count_run = 0
-    total_count_passed = 0
-    total_count_failed = 0
+	total_count_run = 0
+	total_count_passed = 0
+	total_count_failed = 0
 
-    current_path = os.path.dirname(os.path.realpath(__file__))
-    sys.path.append(current_path)
+	current_path = os.path.dirname(os.path.realpath(__file__))
+	sys.path.append(current_path)
 
-    # add current directory path if local is true
-    if local:
-    	local_path = os.path.join(current_path, '..', '..', '..')
-    	if sys.path[1] != local_path:
-    		print 'Adding local path: ', local_path
-    		sys.path.insert(1, local_path)
-    	else:
-            print 'Using local path: ', local_path
+	# add current directory path if local is true
+	if local:
+		local_path = os.path.join(current_path, '..', '..', '..')
+		if sys.path[1] != local_path:
+			print('Adding local path: ', local_path)
+			sys.path.insert(1, local_path)
+		else:
+			print('Using local path: ', local_path)
 
-    print 'pySunSpec version: %s\nTest device path: %s\n' % (sunspec.version, os.path.join(current_path, 'devices'))
+	print('pySunSpec version: %s\nTest device path: %s\n' % (sunspec.version, os.path.join(current_path, 'devices')))
 
-    for m in test_modules:
-        module = __import__(m)
-        (count_run, count_passed, count_failed) = module.test_all(pathlist, stop_on_failure)
-        total_count_run += count_run
-        total_count_passed += count_passed
-        total_count_failed += count_failed
+	for m in test_modules:
+		module = __import__(m)
+		(count_run, count_passed, count_failed) = module.test_all(pathlist, stop_on_failure)
+		total_count_run += count_run
+		total_count_passed += count_passed
+		total_count_failed += count_failed
 
-    print '\nTotal tests run: %d  Total tests passed: %d  Total tests failed: %d' % (total_count_run, total_count_passed, total_count_failed)
-    return (total_count_run, total_count_passed, total_count_failed)
+	print('\nTotal tests run: %d  Total tests passed: %d  Total tests failed: %d' % (total_count_run, total_count_passed, total_count_failed))
+	return (total_count_run, total_count_passed, total_count_failed)
 
 if __name__ == "__main__":
 
-    local = False
+	local = False
 
-    if len(sys.argv) > 1 and sys.argv[1] == 'local':
-    	local = True
+	if len(sys.argv) > 1 and sys.argv[1] == 'local':
+		local = True
 
-    (count_run, count_passed, count_failed) = test_all(local=local)
-    sys.exit(count_failed)
+	(count_run, count_passed, count_failed) = test_all(local=local)
+	sys.exit(count_failed)
diff --git a/sunspec/core/test/test_client.py b/sunspec/core/test/test_client.py
index 3cfe654..4bdbf76 100644
--- a/sunspec/core/test/test_client.py
+++ b/sunspec/core/test/test_client.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2016 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2016 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sys
@@ -30,193 +30,193 @@ import sunspec.core.util as util
 
 def test_client_device(pathlist=None):
 
-    try:
-        d = client.ClientDevice(client.MAPPED, slave_id=1, name='mbmap_test_device_1.xml', pathlist = pathlist)
-        d.scan()
-        d.read_points()
+	try:
+		d = client.ClientDevice(client.MAPPED, slave_id=1, name='mbmap_test_device_1.xml', pathlist = pathlist)
+		d.scan()
+		d.read_points()
 
-        dp = device.Device()
-        dp.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
-        not_equal = dp.not_equal(d)
-        if not_equal:
-            raise Exception(not_equal)
+		dp = device.Device()
+		dp.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
+		not_equal = dp.not_equal(d)
+		if not_equal:
+			raise Exception(not_equal)
 
-    except Exception, e:
-        print '*** Failure test_client_device: %s' % str(e)
-        return False
-    return True
+	except Exception as e:
+		print('*** Failure test_client_device: %s' % str(e))
+		return False
+	return True
 
 def test_sunspec_client_device_1(pathlist=None):
 
-    try:
-        d = client.SunSpecClientDevice(client.MAPPED, slave_id=1, name='mbmap_test_device_1.xml', pathlist = pathlist)
-        d.read()
-
-        dp = device.Device()
-        dp.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
-        not_equal = dp.not_equal(d.device)
-        if not_equal:
-            raise Exception(not_equal)
-
-        expected = 'SunSpecTest'
-        if d.common.Mn != expected:
-            raise Exception("'common.Mn' point mismatch: %s %s" % (d.common.Mn, expected))
-
-        expected = 'sn-123456789'
-        if d.common.SN != expected:
-            raise Exception("'common.SN' point mismatch: %s %s" % (d.common.SN, expected))
-
-
-        # int16 read and write
-        d.model_63001.read()
-        expected = -20
-        if d.model_63001.int16_4 != expected:
-            raise Exception("'model_63001.int16_4' point mismatch: %s %s" % (d.model_63001.int16_4, expected))
-        value = 330
-        d.model_63001.int16_4 = value
-        d.model_63001.write()
-        d.model_63001.read()
-        value = d.model_63001.int16_4
-        if d.model_63001.int16_4 != value:
-            raise Exception("'model_63001.int16_4' write failure: %s %s" % (d.model_63001.int16_4, value))
-
-        # string read and write
-        expected = '12345678'
-        if d.model_63001.string != expected:
-            raise Exception("'model_63001.string' point mismatch: %s %s" % (d.model_63001.string, expected))
-
-        value = 'abcdefg'
-        d.model_63001.string = value
-        d.model_63001.write()
-        d.model_63001.read()
-        if d.model_63001.string != value:
-            raise Exception("'model_63001.string' write failure: %s %s" % (d.model_63001.string, value))
-
-        # write multiple
-        d.model_63001.read()
-        expected = 65524
-        if d.model_63001.uint16_3 != expected:
-            raise Exception("'model_63001.uint16_3' point mismatch: %s %s" % (d.model_63001.uint16_3, expected))
-        expected = 60
-        if d.model_63001.uint16_4 != expected:
-            raise Exception("'model_63001.uint16_4' point mismatch: %s %s" % (d.model_63001.uint16_4, expected))
-        expected = 7
-        if d.model_63001.uint16_5 != expected:
-            raise Exception("'model_63001.uint16_5' point mismatch: %s %s" % (d.model_63001.uint16_5, expected))
-        value_3 = 65525
-        value_4 = 70
-        value_5 = 8
-        d.model_63001.uint16_3 = value_3
-        d.model_63001.uint16_4 = value_4
-        d.model_63001.uint16_5 = value_5
-        d.model_63001.write()
-        d.model_63001.read()
-        value = d.model_63001.uint16_3
-        if d.model_63001.uint16_3 != value_3:
-            raise Exception("'model_63001.int16_3' write failure: %s %s" % (d.model_63001.uint16_3, value_3))
-        value = d.model_63001.uint16_4
-        if d.model_63001.uint16_4 != value_4:
-            raise Exception("'model_63001.int16_4' write failure: %s %s" % (d.model_63001.uint16_4, value_4))
-        value = d.model_63001.uint16_5
-        if d.model_63001.uint16_5 != value_5:
-            raise Exception("'model_63001.int16_5' write failure: %s %s" % (d.model_63001.uint16_5, value_5))
-
-        # write multiple
-        d.model_63001.read()
-        expected = value_3
-        if d.model_63001.uint16_3 != expected:
-            raise Exception("'model_63001.uint16_3' point mismatch: %s %s" % (d.model_63001.uint16_3, expected))
-        expected = value_4
-        if d.model_63001.uint16_4 != expected:
-            raise Exception("'model_63001.uint16_4' point mismatch: %s %s" % (d.model_63001.uint16_4, expected))
-        expected = value_5
-        if d.model_63001.uint16_5 != expected:
-            raise Exception("'model_63001.uint16_5' point mismatch: %s %s" % (d.model_63001.uint16_5, expected))
-        value_3 = 65524
-        value_5 = 7
-        d.model_63001.uint16_3 = value_3
-        d.model_63001.uint16_5 = value_5
-        d.model_63001.write()
-        d.model_63001.read()
-        value = d.model_63001.uint16_3
-        if d.model_63001.uint16_3 != value_3:
-            raise Exception("'model_63001.int16_3' write failure: %s %s" % (d.model_63001.uint16_3, value_3))
-        value = d.model_63001.uint16_4
-        if d.model_63001.uint16_4 != value_4:
-            raise Exception("'model_63001.int16_4' write failure: %s %s" % (d.model_63001.uint16_4, value_4))
-        value = d.model_63001.uint16_5
-        if d.model_63001.uint16_5 != value_5:
-            raise Exception("'model_63001.int16_5' write failure: %s %s" % (d.model_63001.uint16_5, value_5))
-
-        d.close()
-
-    except Exception, e:
-        print '*** Failure test_sunspec_client_device_1: %s' % str(e)
-        return False
-    return True
+	try:
+		d = client.SunSpecClientDevice(client.MAPPED, slave_id=1, name='mbmap_test_device_1.xml', pathlist = pathlist)
+		d.read()
+
+		dp = device.Device()
+		dp.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
+		not_equal = dp.not_equal(d.device)
+		if not_equal:
+			raise Exception(not_equal)
+
+		expected = 'SunSpecTest'
+		if d.common.Mn != expected:
+			raise Exception("'common.Mn' point mismatch: %s %s" % (d.common.Mn, expected))
+
+		expected = 'sn-123456789'
+		if d.common.SN != expected:
+			raise Exception("'common.SN' point mismatch: %s %s" % (d.common.SN, expected))
+
+
+		# int16 read and write
+		d.model_63001.read()
+		expected = -20
+		if d.model_63001.int16_4 != expected:
+			raise Exception("'model_63001.int16_4' point mismatch: %s %s" % (d.model_63001.int16_4, expected))
+		value = 330
+		d.model_63001.int16_4 = value
+		d.model_63001.write()
+		d.model_63001.read()
+		value = d.model_63001.int16_4
+		if d.model_63001.int16_4 != value:
+			raise Exception("'model_63001.int16_4' write failure: %s %s" % (d.model_63001.int16_4, value))
+
+		# string read and write
+		expected = '12345678'
+		if d.model_63001.string != expected:
+			raise Exception("'model_63001.string' point mismatch: %s %s" % (d.model_63001.string, expected))
+
+		value = 'abcdefg'
+		d.model_63001.string = value
+		d.model_63001.write()
+		d.model_63001.read()
+		if d.model_63001.string != value:
+			raise Exception("'model_63001.string' write failure: %s %s" % (d.model_63001.string, value))
+
+		# write multiple
+		d.model_63001.read()
+		expected = 65524
+		if d.model_63001.uint16_3 != expected:
+			raise Exception("'model_63001.uint16_3' point mismatch: %s %s" % (d.model_63001.uint16_3, expected))
+		expected = 60
+		if d.model_63001.uint16_4 != expected:
+			raise Exception("'model_63001.uint16_4' point mismatch: %s %s" % (d.model_63001.uint16_4, expected))
+		expected = 7
+		if d.model_63001.uint16_5 != expected:
+			raise Exception("'model_63001.uint16_5' point mismatch: %s %s" % (d.model_63001.uint16_5, expected))
+		value_3 = 65525
+		value_4 = 70
+		value_5 = 8
+		d.model_63001.uint16_3 = value_3
+		d.model_63001.uint16_4 = value_4
+		d.model_63001.uint16_5 = value_5
+		d.model_63001.write()
+		d.model_63001.read()
+		value = d.model_63001.uint16_3
+		if d.model_63001.uint16_3 != value_3:
+			raise Exception("'model_63001.int16_3' write failure: %s %s" % (d.model_63001.uint16_3, value_3))
+		value = d.model_63001.uint16_4
+		if d.model_63001.uint16_4 != value_4:
+			raise Exception("'model_63001.int16_4' write failure: %s %s" % (d.model_63001.uint16_4, value_4))
+		value = d.model_63001.uint16_5
+		if d.model_63001.uint16_5 != value_5:
+			raise Exception("'model_63001.int16_5' write failure: %s %s" % (d.model_63001.uint16_5, value_5))
+
+		# write multiple
+		d.model_63001.read()
+		expected = value_3
+		if d.model_63001.uint16_3 != expected:
+			raise Exception("'model_63001.uint16_3' point mismatch: %s %s" % (d.model_63001.uint16_3, expected))
+		expected = value_4
+		if d.model_63001.uint16_4 != expected:
+			raise Exception("'model_63001.uint16_4' point mismatch: %s %s" % (d.model_63001.uint16_4, expected))
+		expected = value_5
+		if d.model_63001.uint16_5 != expected:
+			raise Exception("'model_63001.uint16_5' point mismatch: %s %s" % (d.model_63001.uint16_5, expected))
+		value_3 = 65524
+		value_5 = 7
+		d.model_63001.uint16_3 = value_3
+		d.model_63001.uint16_5 = value_5
+		d.model_63001.write()
+		d.model_63001.read()
+		value = d.model_63001.uint16_3
+		if d.model_63001.uint16_3 != value_3:
+			raise Exception("'model_63001.int16_3' write failure: %s %s" % (d.model_63001.uint16_3, value_3))
+		value = d.model_63001.uint16_4
+		if d.model_63001.uint16_4 != value_4:
+			raise Exception("'model_63001.int16_4' write failure: %s %s" % (d.model_63001.uint16_4, value_4))
+		value = d.model_63001.uint16_5
+		if d.model_63001.uint16_5 != value_5:
+			raise Exception("'model_63001.int16_5' write failure: %s %s" % (d.model_63001.uint16_5, value_5))
+
+		d.close()
+
+	except Exception as e:
+		print('*** Failure test_sunspec_client_device_1: %s' % str(e))
+		return False
+	return True
 
 def test_sunspec_client_device_3(pathlist=None):
 
-    try:
-        d = client.SunSpecClientDevice(client.MAPPED, slave_id=1, name='mbmap_test_device_3.xml', pathlist = pathlist)
-
-        # int16 read and write
-        d.model_63002.read()
-        expected = 1111
-        value = int(d.model_63002.repeating[1].int16_1 * 10)
-        if  value != expected:
-            raise Exception("'model_63002.int16_1' point mismatch: %s %s" % (value, expected))
-
-        d.model_63002.repeating[1].int16_1 = 333.3
-        print 'writing...'
-        d.model_63002.write()
-        d.model_63002.read()
-        expected = 3333
-        value = int(d.model_63002.repeating[1].int16_1 * 10)
-        if value != expected:
-            raise Exception("'model_63002.int16_2' write failure: %s %s" % (value, expected))
-
-        expected = 2222
-        value = int(d.model_63002.repeating[1].int16_2 * 100)
-        if  value != expected:
-            raise Exception("'model_63002.int16_1' point mismatch: %s %s" % (value, expected))
-
-        d.close()
-
-    except Exception, e:
-        print '*** Failure test_sunspec_client_device_3: %s' % str(e)
-        return False
-    return True
+	try:
+		d = client.SunSpecClientDevice(client.MAPPED, slave_id=1, name='mbmap_test_device_3.xml', pathlist = pathlist)
+
+		# int16 read and write
+		d.model_63002.read()
+		expected = 1111
+		value = int(d.model_63002.repeating[1].int16_1 * 10)
+		if  value != expected:
+			raise Exception("'model_63002.int16_1' point mismatch: %s %s" % (value, expected))
+
+		d.model_63002.repeating[1].int16_1 = 333.3
+		print('writing...')
+		d.model_63002.write()
+		d.model_63002.read()
+		expected = 3333
+		value = int(d.model_63002.repeating[1].int16_1 * 10)
+		if value != expected:
+			raise Exception("'model_63002.int16_2' write failure: %s %s" % (value, expected))
+
+		expected = 2222
+		value = int(d.model_63002.repeating[1].int16_2 * 100)
+		if  value != expected:
+			raise Exception("'model_63002.int16_1' point mismatch: %s %s" % (value, expected))
+
+		d.close()
+
+	except Exception as e:
+		print('*** Failure test_sunspec_client_device_3: %s' % str(e))
+		return False
+	return True
 
 tests = [
-    test_client_device,
-    test_sunspec_client_device_1,
-    test_sunspec_client_device_3
+	test_client_device,
+	test_sunspec_client_device_1,
+	test_sunspec_client_device_3
 ]
 
 def test_all(pathlist=None, stop_on_failure=True):
 
-    if pathlist is None:
-        pathlist = util.PathList(['.', os.path.join(os.path.dirname(os.path.abspath(__file__)), 'devices')])
+	if pathlist is None:
+		pathlist = util.PathList(['.', os.path.join(os.path.dirname(os.path.abspath(__file__)), 'devices')])
 
-    count_passed = 0
-    count_failed = 0
-    count_run = 0
+	count_passed = 0
+	count_failed = 0
+	count_run = 0
 
-    for test in tests:
-        count_run += 1
-        if test(pathlist) is True:
-            count_passed += 1
-        else:
-            count_failed += 1
-            if stop_on_failure is True:
-                break
+	for test in tests:
+		count_run += 1
+		if test(pathlist) is True:
+			count_passed += 1
+		else:
+			count_failed += 1
+			if stop_on_failure is True:
+				break
 
-    print 'Test client module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(tests), count_run, count_passed, count_failed)
+	print('Test client module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(tests), count_run, count_passed, count_failed))
 
-    return (count_run, count_passed, count_failed)
+	return (count_run, count_passed, count_failed)
 
 if __name__ == "__main__":
 
-    (count_run, count_passed, count_failed) = test_all()
-    sys.exit(count_failed)
+	(count_run, count_passed, count_failed) = test_all()
+	sys.exit(count_failed)
diff --git a/sunspec/core/test/test_data.py b/sunspec/core/test/test_data.py
index 3d6592c..87d2c22 100644
--- a/sunspec/core/test/test_data.py
+++ b/sunspec/core/test/test_data.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2016 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2016 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sys
@@ -29,55 +29,55 @@ import sunspec.core.data as data
 import sunspec.core.util as util
 
 def test_data(pathlist=None):
-    t = 1387560564.48
-    expected_xml = '<sunSpecData><d lid="00:00:00:00:00:01" man="Man" mod="Mod" sn="SN" t="2013-12-20T17:29:24Z"><m id="1"><p id="P1">23</p><p id="P2">24</p></m></d></sunSpecData>'
-
-    try:
-        sd = data.SunSpecData()
-        # def __init__(self, logger_id=None, namespace=None, device_id=None, ifc=None, man=None, mod=None, sn=None, time=None, cid=None):
-        d = sd.device_add(logger_id='00:00:00:00:00:01', man='Man', mod='Mod', sn='SN', timestamp=t)
-        m = d.model_add(1)
-        m.point_add("P1", 23)
-        m.point_add("P2", 24)
-
-        # print sd.to_xml(pretty_print=True)
-        xml = sd.to_xml_str()
-        if xml != expected_xml:
-            raise Exception('XML mismatch: %s %s' % (xml, expected_xml))
-
-    except Exception, e:
-        raise
-        print '*** Failure test_data: %s' % str(e)
-        return False
-    return True
+	t = 1387560564.48
+	expected_xml = '<sunSpecData><d lid="00:00:00:00:00:01" man="Man" mod="Mod" sn="SN" t="2013-12-20T17:29:24Z"><m id="1"><p id="P1">23</p><p id="P2">24</p></m></d></sunSpecData>'
+
+	try:
+		sd = data.SunSpecData()
+		# def __init__(self, logger_id=None, namespace=None, device_id=None, ifc=None, man=None, mod=None, sn=None, time=None, cid=None):
+		d = sd.device_add(logger_id='00:00:00:00:00:01', man='Man', mod='Mod', sn='SN', timestamp=t)
+		m = d.model_add(1)
+		m.point_add("P1", 23)
+		m.point_add("P2", 24)
+
+		# print sd.to_xml(pretty_print=True)
+		xml = sd.to_xml_str()
+		if xml != expected_xml:
+			raise Exception('XML mismatch: %s %s' % (xml, expected_xml))
+
+	except Exception as e:
+		raise
+		print('*** Failure test_data: %s' % str(e))
+		return False
+	return True
 
 tests = [
-    test_data,
+	test_data,
 ]
 
 def test_all(pathlist=None, stop_on_failure=True):
 
-    if pathlist is None:
-        pathlist = util.PathList(['.', os.path.join(os.path.dirname(os.path.abspath(__file__)), 'devices')])
+	if pathlist is None:
+		pathlist = util.PathList(['.', os.path.join(os.path.dirname(os.path.abspath(__file__)), 'devices')])
 
-    count_passed = 0
-    count_failed = 0
-    count_run = 0
+	count_passed = 0
+	count_failed = 0
+	count_run = 0
 
-    for test in tests:
-        count_run += 1
-        if test(pathlist) is True:
-            count_passed += 1
-        else:
-            count_failed += 1
-            if stop_on_failure is True:
-                break
+	for test in tests:
+		count_run += 1
+		if test(pathlist) is True:
+			count_passed += 1
+		else:
+			count_failed += 1
+			if stop_on_failure is True:
+				break
 
-    print 'Test data module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(tests), count_run, count_passed, count_failed)
+	print('Test data module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(tests), count_run, count_passed, count_failed))
 
-    return (count_run, count_passed, count_failed)
+	return (count_run, count_passed, count_failed)
 
 if __name__ == "__main__":
 
-    (count_run, count_passed, count_failed) = test_all()
-    sys.exit(count_failed)
+	(count_run, count_passed, count_failed) = test_all()
+	sys.exit(count_failed)
diff --git a/sunspec/core/test/test_device.py b/sunspec/core/test/test_device.py
index 5421854..19b37df 100644
--- a/sunspec/core/test/test_device.py
+++ b/sunspec/core/test/test_device.py
@@ -1,33 +1,33 @@
 
 """
-    Copyright (C) 2016 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2016 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sys
 import os
 
 try:
-    import xml.etree.ElementTree as ET
+	import xml.etree.ElementTree as ET
 except:
-    import elementtree.ElementTree as ET
+	import elementtree.ElementTree as ET
 
 import sunspec.core.device as device
 import sunspec.core.util as util
@@ -39,551 +39,551 @@ test_device_pointtype_smdx_1 = """
 <sunSpecModels v="1">
   <!-- 1: common -->
   <model id="63001" len="152">
-    <block len="134">
-      <point id="sunssf_1"      offset="0"    type="sunssf" />
-      <point id="sunssf_2"      offset="1"    type="sunssf" />
-      <point id="sunssf_3"      offset="2"    type="sunssf" />
-      <point id="sunssf_4"      offset="3"    type="sunssf" />
-      <point id="int16_1"       offset="4"    type="int16"   sf="sunssf_1"  units="units_1" />
-        <symbol id="SYMBOL_1_1">1</symbol>
-        <symbol id="SYMBOL_1_2">2</symbol>
-        <symbol id="SYMBOL_1_3">3</symbol>
-      <point id="int16_2"       offset="5"    type="int16"   sf="sunssf_2"  units="units_2" />
-        <symbol id="SYMBOL_2_1">1</symbol>
-        <symbol id="SYMBOL_2_2">2</symbol>
-        <symbol id="SYMBOL_2_3">3</symbol>
-      <point id="int16_3"       offset="6"    type="int16"   sf="sunssf_3"  units="units_3" />
-      <point id="int16_4"       offset="7"    type="int16"   sf="sunssf_4"  units="units_4" />
-      <point id="int16_5"       offset="8"    type="int16" />
-      <point id="int16_u"       offset="9"    type="int16" />
-      <point id="uint16_1"      offset="10"   type="uint16"  sf="sunssf_1" />
-      <point id="uint16_2"      offset="11"   type="uint16"  sf="sunssf_2" />
-      <point id="uint16_3"      offset="12"   type="uint16"  sf="sunssf_3" />
-      <point id="uint16_4"      offset="13"   type="uint16"  sf="sunssf_4" />
-      <point id="uint16_5"      offset="14"   type="uint16" />
-      <point id="uint16_u"      offset="15"   type="uint16" />
-      <point id="acc16"         offset="16"   type="acc16" />
-      <point id="acc16_u"       offset="17"   type="acc16" />
-      <point id="enum16"        offset="18"   type="enum16" />
-      <point id="enum16_u"      offset="19"   type="enum16" />
-      <point id="bitfield16"    offset="20"   type="bitfield16" />
-      <point id="bitfield16_u"  offset="21"   type="bitfield16" />
-      <point id="int32_1"       offset="22"   type="int32"   sf="sunssf_5" />
-      <point id="int32_2"       offset="24"   type="int32"   sf="sunssf_6" />
-      <point id="int32_3"       offset="26"   type="int32"   sf="sunssf_7" />
-      <point id="int32_4"       offset="28"   type="int32" />
-      <point id="int32_5"       offset="30"   type="int32" />
-      <point id="int32_u"       offset="32"   type="int32" />
-      <point id="uint32_1"      offset="34"   type="uint32"  sf="sunssf_5" />
-      <point id="uint32_2"      offset="36"   type="uint32"  sf="sunssf_6" />
-      <point id="uint32_3"      offset="38"   type="uint32"  sf="sunssf_7" />
-      <point id="uint32_4"      offset="40"   type="uint32"  sf="1" />
-      <point id="uint32_5"      offset="42"   type="uint32" />
-      <point id="uint32_u"      offset="44"   type="uint32" />
-      <point id="acc32"         offset="46"   type="acc32" />
-      <point id="acc32_u"       offset="48"   type="acc32" />
-      <point id="enum32"        offset="50"   type="enum32" />
-      <point id="enum32_u"      offset="52"   type="enum32" />
-      <point id="bitfield32"    offset="54"   type="bitfield32" />
-      <point id="bitfield32_u"  offset="56"   type="bitfield32" />
-      <point id="ipaddr"        offset="58"   type="ipaddr" />
-      <point id="ipaddr_u"      offset="60"   type="ipaddr" />
-      <point id="int64"         offset="62"   type="int64" />
-      <point id="int64_u"       offset="66"   type="int64" />
-      <point id="acc64"         offset="70"   type="acc64" />
-      <point id="acc64_u"       offset="74"   type="int64" />
-      <point id="ipv6addr"      offset="78"   type="ipv6addr" />
-      <point id="ipv6addr_u"    offset="86"   type="ipv6addr" />
-      <point id="float32"       offset="94"   type="float32" />
-      <point id="float32_u"     offset="96"   type="float32" />
-      <point id="string"        offset="98"   type="string"  len="16"/>
-      <point id="string_u"      offset="114"  type="string"  len="16"/>
-      <point id="sunssf_5"      offset="130"  type="sunssf" />
-      <point id="sunssf_6"      offset="131"  type="sunssf" />
-      <point id="sunssf_7"      offset="132"  type="sunssf" />
-      <point id="pad_1"         offset="133"  type="pad" />
-    </block>
-    <block type="repeating" len="18">
-      <point id="sunssf_8"      offset="0"    type="sunssf" />
-      <point id="int16_11"      offset="1"    type="int16"   sf="sunssf_8" />
-      <point id="int16_12"      offset="2"    type="int16"   sf="sunssf_9" />
-      <point id="int16_u"       offset="3"    type="int16" />
-      <point id="uint16_11"     offset="4"    type="uint16"  sf="sunssf_8" />
-      <point id="uint16_12"     offset="5"    type="uint16"  sf="sunssf_9" />
-      <point id="uint16_13"     offset="6"    type="uint16" />
-      <point id="uint16_u"      offset="7"    type="uint16" />
-      <point id="int32"         offset="8"    type="int32"   sf="sunssf_1" />
-      <point id="int32_u"       offset="10"   type="int32" />
-      <point id="uint32"        offset="12"   type="uint32"  sf="sunssf_9" />
-      <point id="uint32_u"      offset="14"   type="uint32" />
-      <point id="sunssf_9"      offset="16"   type="sunssf" />
-      <point id="pad_2"         offset="17"   type="pad" />
-    </block>
+	<block len="134">
+	  <point id="sunssf_1"	  offset="0"	type="sunssf" />
+	  <point id="sunssf_2"	  offset="1"	type="sunssf" />
+	  <point id="sunssf_3"	  offset="2"	type="sunssf" />
+	  <point id="sunssf_4"	  offset="3"	type="sunssf" />
+	  <point id="int16_1"	   offset="4"	type="int16"   sf="sunssf_1"  units="units_1" />
+		<symbol id="SYMBOL_1_1">1</symbol>
+		<symbol id="SYMBOL_1_2">2</symbol>
+		<symbol id="SYMBOL_1_3">3</symbol>
+	  <point id="int16_2"	   offset="5"	type="int16"   sf="sunssf_2"  units="units_2" />
+		<symbol id="SYMBOL_2_1">1</symbol>
+		<symbol id="SYMBOL_2_2">2</symbol>
+		<symbol id="SYMBOL_2_3">3</symbol>
+	  <point id="int16_3"	   offset="6"	type="int16"   sf="sunssf_3"  units="units_3" />
+	  <point id="int16_4"	   offset="7"	type="int16"   sf="sunssf_4"  units="units_4" />
+	  <point id="int16_5"	   offset="8"	type="int16" />
+	  <point id="int16_u"	   offset="9"	type="int16" />
+	  <point id="uint16_1"	  offset="10"   type="uint16"  sf="sunssf_1" />
+	  <point id="uint16_2"	  offset="11"   type="uint16"  sf="sunssf_2" />
+	  <point id="uint16_3"	  offset="12"   type="uint16"  sf="sunssf_3" />
+	  <point id="uint16_4"	  offset="13"   type="uint16"  sf="sunssf_4" />
+	  <point id="uint16_5"	  offset="14"   type="uint16" />
+	  <point id="uint16_u"	  offset="15"   type="uint16" />
+	  <point id="acc16"		 offset="16"   type="acc16" />
+	  <point id="acc16_u"	   offset="17"   type="acc16" />
+	  <point id="enum16"		offset="18"   type="enum16" />
+	  <point id="enum16_u"	  offset="19"   type="enum16" />
+	  <point id="bitfield16"	offset="20"   type="bitfield16" />
+	  <point id="bitfield16_u"  offset="21"   type="bitfield16" />
+	  <point id="int32_1"	   offset="22"   type="int32"   sf="sunssf_5" />
+	  <point id="int32_2"	   offset="24"   type="int32"   sf="sunssf_6" />
+	  <point id="int32_3"	   offset="26"   type="int32"   sf="sunssf_7" />
+	  <point id="int32_4"	   offset="28"   type="int32" />
+	  <point id="int32_5"	   offset="30"   type="int32" />
+	  <point id="int32_u"	   offset="32"   type="int32" />
+	  <point id="uint32_1"	  offset="34"   type="uint32"  sf="sunssf_5" />
+	  <point id="uint32_2"	  offset="36"   type="uint32"  sf="sunssf_6" />
+	  <point id="uint32_3"	  offset="38"   type="uint32"  sf="sunssf_7" />
+	  <point id="uint32_4"	  offset="40"   type="uint32"  sf="1" />
+	  <point id="uint32_5"	  offset="42"   type="uint32" />
+	  <point id="uint32_u"	  offset="44"   type="uint32" />
+	  <point id="acc32"		 offset="46"   type="acc32" />
+	  <point id="acc32_u"	   offset="48"   type="acc32" />
+	  <point id="enum32"		offset="50"   type="enum32" />
+	  <point id="enum32_u"	  offset="52"   type="enum32" />
+	  <point id="bitfield32"	offset="54"   type="bitfield32" />
+	  <point id="bitfield32_u"  offset="56"   type="bitfield32" />
+	  <point id="ipaddr"		offset="58"   type="ipaddr" />
+	  <point id="ipaddr_u"	  offset="60"   type="ipaddr" />
+	  <point id="int64"		 offset="62"   type="int64" />
+	  <point id="int64_u"	   offset="66"   type="int64" />
+	  <point id="acc64"		 offset="70"   type="acc64" />
+	  <point id="acc64_u"	   offset="74"   type="int64" />
+	  <point id="ipv6addr"	  offset="78"   type="ipv6addr" />
+	  <point id="ipv6addr_u"	offset="86"   type="ipv6addr" />
+	  <point id="float32"	   offset="94"   type="float32" />
+	  <point id="float32_u"	 offset="96"   type="float32" />
+	  <point id="string"		offset="98"   type="string"  len="16"/>
+	  <point id="string_u"	  offset="114"  type="string"  len="16"/>
+	  <point id="sunssf_5"	  offset="130"  type="sunssf" />
+	  <point id="sunssf_6"	  offset="131"  type="sunssf" />
+	  <point id="sunssf_7"	  offset="132"  type="sunssf" />
+	  <point id="pad_1"		 offset="133"  type="pad" />
+	</block>
+	<block type="repeating" len="18">
+	  <point id="sunssf_8"	  offset="0"	type="sunssf" />
+	  <point id="int16_11"	  offset="1"	type="int16"   sf="sunssf_8" />
+	  <point id="int16_12"	  offset="2"	type="int16"   sf="sunssf_9" />
+	  <point id="int16_u"	   offset="3"	type="int16" />
+	  <point id="uint16_11"	 offset="4"	type="uint16"  sf="sunssf_8" />
+	  <point id="uint16_12"	 offset="5"	type="uint16"  sf="sunssf_9" />
+	  <point id="uint16_13"	 offset="6"	type="uint16" />
+	  <point id="uint16_u"	  offset="7"	type="uint16" />
+	  <point id="int32"		 offset="8"	type="int32"   sf="sunssf_1" />
+	  <point id="int32_u"	   offset="10"   type="int32" />
+	  <point id="uint32"		offset="12"   type="uint32"  sf="sunssf_9" />
+	  <point id="uint32_u"	  offset="14"   type="uint32" />
+	  <point id="sunssf_9"	  offset="16"   type="sunssf" />
+	  <point id="pad_2"		 offset="17"   type="pad" />
+	</block>
   </model>
 
   <strings id="63001" locale="en">
-    <model>
-      <label>Model 63001 label</label>
-      <description>SunSpec test model 63001</description>
-      <notes>Provides testing for all SunSpec smdx elements and attributes</notes>
-    </model>
+	<model>
+	  <label>Model 63001 label</label>
+	  <description>SunSpec test model 63001</description>
+	  <notes>Provides testing for all SunSpec smdx elements and attributes</notes>
+	</model>
   </strings>
 
 </sunSpecModels>
 """
 
 test_device_pointtype_smdx_2 = """
-    <block len="134">
-      <point id="p_int16"       offset="0"    type="int16" />
-      <point id="p_uint16"      offset="1"    type="uint16" />
-      <point id="p_acc16"       offset="2"    type="acc16" />
-      <point id="p_enum16"      offset="3"    type="enum16" />
-      <point id="p_bitfield16"  offset="4"    type="bitfield16" />
-      <point id="p_int32"       offset="5"    type="int32" />
-      <point id="p_uint32"      offset="7"    type="uint32" />
-      <point id="p_acc32"       offset="9"    type="acc32" />
-      <point id="p_enum32"      offset="11"   type="enum32" />
-      <point id="p_bitfield32"  offset="13"   type="bitfield32" />
-      <point id="p_ipaddr"      offset="15"   type="ipaddr" />
-      <point id="p_int64"       offset="17"   type="int64" />
-      <point id="p_acc64"       offset="21"   type="acc64" />
-      <point id="p_ipv6addr"    offset="25"   type="ipv6addr" />
-      <point id="p_float32"     offset="33"   type="float32" />
-      <point id="p_string"      offset="35"   type="string"     len="8" />
-      <point id="p_sunssf"      offset="43"   type="sunssf" />
-      <point id="p_pad"         offset="44"   type="pad" />
-    </block>
+	<block len="134">
+	  <point id="p_int16"	   offset="0"	type="int16" />
+	  <point id="p_uint16"	  offset="1"	type="uint16" />
+	  <point id="p_acc16"	   offset="2"	type="acc16" />
+	  <point id="p_enum16"	  offset="3"	type="enum16" />
+	  <point id="p_bitfield16"  offset="4"	type="bitfield16" />
+	  <point id="p_int32"	   offset="5"	type="int32" />
+	  <point id="p_uint32"	  offset="7"	type="uint32" />
+	  <point id="p_acc32"	   offset="9"	type="acc32" />
+	  <point id="p_enum32"	  offset="11"   type="enum32" />
+	  <point id="p_bitfield32"  offset="13"   type="bitfield32" />
+	  <point id="p_ipaddr"	  offset="15"   type="ipaddr" />
+	  <point id="p_int64"	   offset="17"   type="int64" />
+	  <point id="p_acc64"	   offset="21"   type="acc64" />
+	  <point id="p_ipv6addr"	offset="25"   type="ipv6addr" />
+	  <point id="p_float32"	 offset="33"   type="float32" />
+	  <point id="p_string"	  offset="35"   type="string"	 len="8" />
+	  <point id="p_sunssf"	  offset="43"   type="sunssf" />
+	  <point id="p_pad"		 offset="44"   type="pad" />
+	</block>
 """
 
 def create_test_device_1():
 
-    d = device.Device()
-
-    # create model 1 with values
-    m1 = device.Model(device=d, mid=1)
-    m1.load()
-    d.models_list.append(m1)
-    b = m1.blocks[0]
-    b.points['Mn'].value_base = 'SunSpecTest'
-    b.points['Md'].value_base = 'TestDevice-1'
-    b.points['Opt'].value_base = 'opt_a_b_c'
-    b.points['Vr'].value_base = '1.2.3'
-    b.points['SN'].value_base = 'sn-123456789'
-    b.points['DA'].value_base = 1
-
-    # create model 63001 with values
-    m2 = device.Model(device=d, mid=63001, mlen=188)
-    m2.load()
-    d.models_list.append(m2)
-
-    # fixed block
-    b = m2.blocks[0]
-    b.points_sf['sunssf_1'].value_base = -10
-    b.points_sf['sunssf_2'].value_base = 10
-    b.points_sf['sunssf_3'].value_base = 0
-    b.points_sf['sunssf_4'].value_base = 1
-    b.points_sf['sunssf_5'].value_base = 2
-    b.points_sf['sunssf_6'].value_base = 3
-    b.points_sf['sunssf_7'].value_base = 4
-
-    b.points['int16_1'].value_base = 1
-    b.points['int16_2'].value_base = -1
-    b.points['int16_3'].value_base = 2
-    b.points['int16_4'].value_base = -2
-    b.points['int16_5'].value_base = 3
-    b.points['int16_u'].value_base = None
-    b.points['uint16_1'].value_base = 4
-    b.points['uint16_2'].value_base = 5
-    b.points['uint16_3'].value_base = 65524
-    b.points['uint16_4'].value_base = 6
-    b.points['uint16_5'].value_base = 7
-    b.points['uint16_u'].value_base = None
-    b.points['acc16'].value_base = 8
-    b.points['acc16_u'].value_base = None
-    b.points['enum16'].value_base = 9
-    b.points['enum16_u'].value_base = None
-    b.points['bitfield16'].value_base =  10
-    b.points['bitfield16_u'].value_base = None
-    b.points['int32_1'].value_base = 11
-    b.points['int32_2'].value_base = 12
-    b.points['int32_3'].value_base = 13
-    b.points['int32_4'].value_base = 14
-    b.points['int32_5'].value_base = 15
-    b.points['int32_u'].value_base = None
-    b.points['uint32_1'].value_base = 16
-    b.points['uint32_2'].value_base = 17
-    b.points['uint32_3'].value_base = 18
-    b.points['uint32_4'].value_base = 19
-    b.points['uint32_5'].value_base = 20
-    b.points['uint32_u'].value_base = None
-    b.points['acc32'].value_base = 21
-    b.points['acc32_u'].value_base = None
-    b.points['enum32'].value_base = 22
-    b.points['enum32_u'].value_base = None
-    b.points['bitfield32'].value_base = 23
-    b.points['bitfield32_u'].value_base = None
-    b.points['ipaddr'].value_base = 0x01020304
-    b.points['ipaddr_u'].value_base = None
-    b.points['int64'].value_base = 24
-    b.points['int64_u'].value_base = None
-    b.points['acc64'].value_base = 25
-    b.points['acc64_u'].value_base = None
-    b.points['ipv6addr'].value_base = None
-    b.points['ipv6addr_u'].value_base = None
-    b.points['float32'].value_base = 26
-    b.points['float32_u'].value_base = None
-    b.points['string'].value_base = '12345678'
-    b.points['string_u'].value_base = None
-
-    # repeating block 1
-    b = m2.blocks[1]
-    b.points_sf['sunssf_8'].value_base = -2
-    b.points_sf['sunssf_9'].value_base = -3
-
-    b.points['int16_11'].value_base = 30
-    b.points['int16_12'].value_base = 31
-    b.points['int16_u'].value_base = None
-    b.points['uint16_11'].value_base = 32
-    b.points['uint16_12'].value_base = 33
-    b.points['uint16_13'].value_base = 34
-    b.points['uint16_u'].value_base = None
-    b.points['int32'].value_base = 35
-    b.points['int32_u'].value_base = None
-    b.points['uint32'].value_base = 36
-    b.points['uint32_u'].value_base = None
-
-    # repeating block 2
-    b = m2.blocks[2]
-    b.points_sf['sunssf_8'].value_base = -4
-    b.points_sf['sunssf_9'].value_base = -5
-
-    b.points['int16_11'].value_base = 40
-    b.points['int16_12'].value_base = 41
-    b.points['int16_u'].value_base = None
-    b.points['uint16_11'].value_base = 42
-    b.points['uint16_12'].value_base = 43
-    b.points['uint16_13'].value_base = 44
-    b.points['uint16_u'].value_base = None
-    b.points['int32'].value_base = 45
-    b.points['int32_u'].value_base = None
-    b.points['uint32'].value_base = 46
-    b.points['uint32_u'].value_base = None
-
-    # repeating block 3
-    b = m2.blocks[3]
-    b.points_sf['sunssf_8'].value_base = 2
-    b.points_sf['sunssf_9'].value_base = 3
-
-    b.points['int16_11'].value_base = 50
-    b.points['int16_12'].value_base = 51
-    b.points['int16_u'].value_base = None
-    b.points['uint16_11'].value_base = 52
-    b.points['uint16_12'].value_base = 53
-    b.points['uint16_13'].value_base = 54
-    b.points['uint16_u'].value_base = None
-    b.points['int32'].value_base = 55
-    b.points['int32_u'].value_base = None
-    b.points['uint32'].value_base = 56
-    b.points['uint32_u'].value_base = None
-
-    # update scale factor values in points
-    for block in m2.blocks:
-        for point in block.points_list:
-            if point.sf_point is not None:
-                point.value_sf = point.sf_point.value_base
-
-    return d
+	d = device.Device()
+
+	# create model 1 with values
+	m1 = device.Model(device=d, mid=1)
+	m1.load()
+	d.models_list.append(m1)
+	b = m1.blocks[0]
+	b.points['Mn'].value_base = 'SunSpecTest'
+	b.points['Md'].value_base = 'TestDevice-1'
+	b.points['Opt'].value_base = 'opt_a_b_c'
+	b.points['Vr'].value_base = '1.2.3'
+	b.points['SN'].value_base = 'sn-123456789'
+	b.points['DA'].value_base = 1
+
+	# create model 63001 with values
+	m2 = device.Model(device=d, mid=63001, mlen=188)
+	m2.load()
+	d.models_list.append(m2)
+
+	# fixed block
+	b = m2.blocks[0]
+	b.points_sf['sunssf_1'].value_base = -10
+	b.points_sf['sunssf_2'].value_base = 10
+	b.points_sf['sunssf_3'].value_base = 0
+	b.points_sf['sunssf_4'].value_base = 1
+	b.points_sf['sunssf_5'].value_base = 2
+	b.points_sf['sunssf_6'].value_base = 3
+	b.points_sf['sunssf_7'].value_base = 4
+
+	b.points['int16_1'].value_base = 1
+	b.points['int16_2'].value_base = -1
+	b.points['int16_3'].value_base = 2
+	b.points['int16_4'].value_base = -2
+	b.points['int16_5'].value_base = 3
+	b.points['int16_u'].value_base = None
+	b.points['uint16_1'].value_base = 4
+	b.points['uint16_2'].value_base = 5
+	b.points['uint16_3'].value_base = 65524
+	b.points['uint16_4'].value_base = 6
+	b.points['uint16_5'].value_base = 7
+	b.points['uint16_u'].value_base = None
+	b.points['acc16'].value_base = 8
+	b.points['acc16_u'].value_base = None
+	b.points['enum16'].value_base = 9
+	b.points['enum16_u'].value_base = None
+	b.points['bitfield16'].value_base =  10
+	b.points['bitfield16_u'].value_base = None
+	b.points['int32_1'].value_base = 11
+	b.points['int32_2'].value_base = 12
+	b.points['int32_3'].value_base = 13
+	b.points['int32_4'].value_base = 14
+	b.points['int32_5'].value_base = 15
+	b.points['int32_u'].value_base = None
+	b.points['uint32_1'].value_base = 16
+	b.points['uint32_2'].value_base = 17
+	b.points['uint32_3'].value_base = 18
+	b.points['uint32_4'].value_base = 19
+	b.points['uint32_5'].value_base = 20
+	b.points['uint32_u'].value_base = None
+	b.points['acc32'].value_base = 21
+	b.points['acc32_u'].value_base = None
+	b.points['enum32'].value_base = 22
+	b.points['enum32_u'].value_base = None
+	b.points['bitfield32'].value_base = 23
+	b.points['bitfield32_u'].value_base = None
+	b.points['ipaddr'].value_base = 0x01020304
+	b.points['ipaddr_u'].value_base = None
+	b.points['int64'].value_base = 24
+	b.points['int64_u'].value_base = None
+	b.points['acc64'].value_base = 25
+	b.points['acc64_u'].value_base = None
+	b.points['ipv6addr'].value_base = None
+	b.points['ipv6addr_u'].value_base = None
+	b.points['float32'].value_base = 26
+	b.points['float32_u'].value_base = None
+	b.points['string'].value_base = '12345678'
+	b.points['string_u'].value_base = None
+
+	# repeating block 1
+	b = m2.blocks[1]
+	b.points_sf['sunssf_8'].value_base = -2
+	b.points_sf['sunssf_9'].value_base = -3
+
+	b.points['int16_11'].value_base = 30
+	b.points['int16_12'].value_base = 31
+	b.points['int16_u'].value_base = None
+	b.points['uint16_11'].value_base = 32
+	b.points['uint16_12'].value_base = 33
+	b.points['uint16_13'].value_base = 34
+	b.points['uint16_u'].value_base = None
+	b.points['int32'].value_base = 35
+	b.points['int32_u'].value_base = None
+	b.points['uint32'].value_base = 36
+	b.points['uint32_u'].value_base = None
+
+	# repeating block 2
+	b = m2.blocks[2]
+	b.points_sf['sunssf_8'].value_base = -4
+	b.points_sf['sunssf_9'].value_base = -5
+
+	b.points['int16_11'].value_base = 40
+	b.points['int16_12'].value_base = 41
+	b.points['int16_u'].value_base = None
+	b.points['uint16_11'].value_base = 42
+	b.points['uint16_12'].value_base = 43
+	b.points['uint16_13'].value_base = 44
+	b.points['uint16_u'].value_base = None
+	b.points['int32'].value_base = 45
+	b.points['int32_u'].value_base = None
+	b.points['uint32'].value_base = 46
+	b.points['uint32_u'].value_base = None
+
+	# repeating block 3
+	b = m2.blocks[3]
+	b.points_sf['sunssf_8'].value_base = 2
+	b.points_sf['sunssf_9'].value_base = 3
+
+	b.points['int16_11'].value_base = 50
+	b.points['int16_12'].value_base = 51
+	b.points['int16_u'].value_base = None
+	b.points['uint16_11'].value_base = 52
+	b.points['uint16_12'].value_base = 53
+	b.points['uint16_13'].value_base = 54
+	b.points['uint16_u'].value_base = None
+	b.points['int32'].value_base = 55
+	b.points['int32_u'].value_base = None
+	b.points['uint32'].value_base = 56
+	b.points['uint32_u'].value_base = None
+
+	# update scale factor values in points
+	for block in m2.blocks:
+		for point in block.points_list:
+			if point.sf_point is not None:
+				point.value_sf = point.sf_point.value_base
+
+	return d
 
 def test_device_modeltype(pathlist=None):
-    mt = device.ModelType()
+	mt = device.ModelType()
 
-    try:
-        root = ET.fromstring(test_device_pointtype_smdx_1)
-        mt.from_smdx(root)
+	try:
+		root = ET.fromstring(test_device_pointtype_smdx_1)
+		mt.from_smdx(root)
 
-        if mt.id != 63001 or mt.len != 152:
-            raise Exception('model type attribute error: id = %s  len = %d' % (mt.id, mt.len))
+		if mt.id != 63001 or mt.len != 152:
+			raise Exception('model type attribute error: id = %s  len = %d' % (mt.id, mt.len))
 
-    except Exception, e:
-        raise
-        print '*** Failure test_device_modeltype: %s' % (str(e))
-        return False
+	except Exception as e:
+		raise
+		print('*** Failure test_device_modeltype: %s' % (str(e)))
+		return False
 
-    return True
+	return True
 
 def test_device_pointtype(pathlist=None):
-    points = {}
-
-    try:
-        block = ET.fromstring(test_device_pointtype_smdx_2)
-        for p in block.findall('*'):
-            pt = device.PointType()
-            pt.from_smdx(p)
-            points[p.attrib.get(smdx.SMDX_ATTR_ID)] = pt
-
-        pt = points.get('p_int16')
-        if (pt.id != 'p_int16' or pt.offset != 0 or pt.type != suns.SUNS_TYPE_INT16 or pt.len != 1):
-            raise Exception('p_int16 error')
-    except Exception, e:
-        print '*** Failure test_device_pointtype: %s' % (str(e))
-        return False
-    return True
+	points = {}
+
+	try:
+		block = ET.fromstring(test_device_pointtype_smdx_2)
+		for p in block.findall('*'):
+			pt = device.PointType()
+			pt.from_smdx(p)
+			points[p.attrib.get(smdx.SMDX_ATTR_ID)] = pt
+
+		pt = points.get('p_int16')
+		if (pt.id != 'p_int16' or pt.offset != 0 or pt.type != suns.SUNS_TYPE_INT16 or pt.len != 1):
+			raise Exception('p_int16 error')
+	except Exception as e:
+		print('*** Failure test_device_pointtype: %s' % (str(e)))
+		return False
+	return True
 
 def test_device_pointtype_not_equal(pathlist=None):
-    pt1 = device.PointType('point_1', 0, smdx.SMDX_TYPE_INT16)
-    pt2 = device.PointType('point_1', 0, smdx.SMDX_TYPE_INT16)
-    pt3 = device.PointType('point_1', 0, smdx.SMDX_TYPE_INT16)
-
-    try:
-        not_equal = pt1.not_equal(pt2)
-        if not_equal:
-            raise Exception(not_equal)
-
-        not_equal = pt1.not_equal(pt3)
-        if not_equal:
-            raise Exception(not_equal)
-    except Exception, e:
-        print '*** Failure test_device_pointtype_not_equal: %s' % str(e)
-        return False
-    return True
+	pt1 = device.PointType('point_1', 0, smdx.SMDX_TYPE_INT16)
+	pt2 = device.PointType('point_1', 0, smdx.SMDX_TYPE_INT16)
+	pt3 = device.PointType('point_1', 0, smdx.SMDX_TYPE_INT16)
+
+	try:
+		not_equal = pt1.not_equal(pt2)
+		if not_equal:
+			raise Exception(not_equal)
+
+		not_equal = pt1.not_equal(pt3)
+		if not_equal:
+			raise Exception(not_equal)
+	except Exception as e:
+		print('*** Failure test_device_pointtype_not_equal: %s' % str(e))
+		return False
+	return True
 
 def test_device_blocktype_not_equal(pathlist=None):
-    pt1a = device.PointType('point_1', 0, suns.SUNS_TYPE_INT16)
-    pt1b = device.PointType('point_1', 0, suns.SUNS_TYPE_INT16)
-    pt2a = device.PointType('point_2', 0, suns.SUNS_TYPE_UINT16)
-    pt2b = device.PointType('point_2', 0, suns.SUNS_TYPE_UINT16)
-    bt1a = device.BlockType(suns.SUNS_BLOCK_FIXED, 20)
-    bt1b = device.BlockType(suns.SUNS_BLOCK_FIXED, 20)
-    bt1a.points[pt1a.id] = pt1a
-    bt1a.points[pt2a.id] = pt2a
-    bt1b.points[pt1b.id] = pt1b
-    bt1b.points[pt2b.id] = pt2b
-    bt2a = device.BlockType(suns.SUNS_BLOCK_REPEATING, 30)
-    bt2b = device.BlockType(suns.SUNS_BLOCK_REPEATING, 30)
-
-    try:
-        not_equal = bt1a.not_equal(bt1b)
-        if not_equal:
-            raise Exception(not_equal)
-
-        not_equal = bt2a.not_equal(bt2b)
-        if not_equal:
-            raise Exception(not_equal)
-    except Exception, e:
-        print '*** Failure test_device_blocktype_not_equal: %s' % str(e)
-        return False
-    return True
+	pt1a = device.PointType('point_1', 0, suns.SUNS_TYPE_INT16)
+	pt1b = device.PointType('point_1', 0, suns.SUNS_TYPE_INT16)
+	pt2a = device.PointType('point_2', 0, suns.SUNS_TYPE_UINT16)
+	pt2b = device.PointType('point_2', 0, suns.SUNS_TYPE_UINT16)
+	bt1a = device.BlockType(suns.SUNS_BLOCK_FIXED, 20)
+	bt1b = device.BlockType(suns.SUNS_BLOCK_FIXED, 20)
+	bt1a.points[pt1a.id] = pt1a
+	bt1a.points[pt2a.id] = pt2a
+	bt1b.points[pt1b.id] = pt1b
+	bt1b.points[pt2b.id] = pt2b
+	bt2a = device.BlockType(suns.SUNS_BLOCK_REPEATING, 30)
+	bt2b = device.BlockType(suns.SUNS_BLOCK_REPEATING, 30)
+
+	try:
+		not_equal = bt1a.not_equal(bt1b)
+		if not_equal:
+			raise Exception(not_equal)
+
+		not_equal = bt2a.not_equal(bt2b)
+		if not_equal:
+			raise Exception(not_equal)
+	except Exception as e:
+		print('*** Failure test_device_blocktype_not_equal: %s' % str(e))
+		return False
+	return True
 
 def test_device_modeltype_not_equal(pathlist=None):
-    pt1a = device.PointType('point_1', 0, suns.SUNS_TYPE_INT16)
-    pt1b = device.PointType('point_1', 0, suns.SUNS_TYPE_INT16)
-    pt2a = device.PointType('point_2', 0, suns.SUNS_TYPE_UINT16)
-    pt2b = device.PointType('point_2', 0, suns.SUNS_TYPE_UINT16)
-    bt1a = device.BlockType(suns.SUNS_BLOCK_FIXED, 20)
-    bt1b = device.BlockType(suns.SUNS_BLOCK_FIXED, 20)
-    bt1a.points[pt1a.id] = pt1a
-    bt1a.points[pt2a.id] = pt2a
-    bt1b.points[pt1b.id] = pt1b
-    bt1b.points[pt2b.id] = pt2b
-    bt2a = device.BlockType(suns.SUNS_BLOCK_REPEATING, 30)
-    bt2b = device.BlockType(suns.SUNS_BLOCK_REPEATING, 30)
-    mt1 = device.ModelType(1)
-    mt2 = device.ModelType(1)
-    mt1.fixed_block = bt1a
-    mt1.repeating_block = bt2a
-    mt2.fixed_block = bt1b
-    mt2.repeating_block = bt2b
-
-    try:
-        not_equal = mt1.not_equal(mt2)
-        if not_equal:
-            raise Exception(not_equal)
-
-    except Exception, e:
-        print '*** Failure test_device_blocktype_not_equal: %s' % str(e)
-        return False
-    return True
+	pt1a = device.PointType('point_1', 0, suns.SUNS_TYPE_INT16)
+	pt1b = device.PointType('point_1', 0, suns.SUNS_TYPE_INT16)
+	pt2a = device.PointType('point_2', 0, suns.SUNS_TYPE_UINT16)
+	pt2b = device.PointType('point_2', 0, suns.SUNS_TYPE_UINT16)
+	bt1a = device.BlockType(suns.SUNS_BLOCK_FIXED, 20)
+	bt1b = device.BlockType(suns.SUNS_BLOCK_FIXED, 20)
+	bt1a.points[pt1a.id] = pt1a
+	bt1a.points[pt2a.id] = pt2a
+	bt1b.points[pt1b.id] = pt1b
+	bt1b.points[pt2b.id] = pt2b
+	bt2a = device.BlockType(suns.SUNS_BLOCK_REPEATING, 30)
+	bt2b = device.BlockType(suns.SUNS_BLOCK_REPEATING, 30)
+	mt1 = device.ModelType(1)
+	mt2 = device.ModelType(1)
+	mt1.fixed_block = bt1a
+	mt1.repeating_block = bt2a
+	mt2.fixed_block = bt1b
+	mt2.repeating_block = bt2b
+
+	try:
+		not_equal = mt1.not_equal(mt2)
+		if not_equal:
+			raise Exception(not_equal)
+
+	except Exception as e:
+		print('*** Failure test_device_blocktype_not_equal: %s' % str(e))
+		return False
+	return True
 
 def test_device_model_type_get(pathlist=None):
-    try:
-        device.model_type_get(221)
-    except Exception, e:
-        print '*** Failure test_model_type_get: %s' % str(e)
-        return False
-    return True
+	try:
+		device.model_type_get(221)
+	except Exception as e:
+		print('*** Failure test_model_type_get: %s' % str(e))
+		return False
+	return True
 
 def test_device_from_pics(pathlist=None):
-    try:
-        d1 = device.Device()
-        d1.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
-        d2 = create_test_device_1()
-        not_equal = d1.not_equal(d2)
-        if not_equal:
-            raise Exception(not_equal)
-    except Exception, e:
-        raise
-        print '*** Failure test_device_from_pics: %s' % str(e)
-        return False
-    return True
+	try:
+		d1 = device.Device()
+		d1.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
+		d2 = create_test_device_1()
+		not_equal = d1.not_equal(d2)
+		if not_equal:
+			raise Exception(not_equal)
+	except Exception as e:
+		raise
+		print('*** Failure test_device_from_pics: %s' % str(e))
+		return False
+	return True
 
 def test_device_to_pics(pathlist=None):
-    try:
-        d1 = device.Device()
-        d1.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
-
-        root = ET.Element(pics.PICS_ROOT)
-        d1.to_pics(root, single_repeating=False)
-        # util.indent(root)
-        # print ET.tostring(root)
-
-        d = root.find(pics.PICS_DEVICE)
-        if d is None:
-            raise Exception("No '%s' elements found in '%s' element" % (pics.PICS_DEVICE, root.tag))
-
-        d2 = device.Device()
-        d2.from_pics(element=d)
-
-        not_equal = d1.not_equal(d2)
-        if not_equal:
-            raise Exception(not_equal)
-    except Exception, e:
-        print '*** Failure test_device_to_pics: %s' % str(e)
-        return False
-    return True
+	try:
+		d1 = device.Device()
+		d1.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
+
+		root = ET.Element(pics.PICS_ROOT)
+		d1.to_pics(root, single_repeating=False)
+		# util.indent(root)
+		# print(ET.tostring(root))
+
+		d = root.find(pics.PICS_DEVICE)
+		if d is None:
+			raise Exception("No '%s' elements found in '%s' element" % (pics.PICS_DEVICE, root.tag))
+
+		d2 = device.Device()
+		d2.from_pics(element=d)
+
+		not_equal = d1.not_equal(d2)
+		if not_equal:
+			raise Exception(not_equal)
+	except Exception as e:
+		print('*** Failure test_device_to_pics: %s' % str(e))
+		return False
+	return True
 
 def test_device_value_get(pathlist=None):
-    try:
-        d = device.Device()
-        d.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
-
-        m = d.models[63001][0]
-        p = 'int16_4'
-        value = m.points[p].value
-        expected_value = -20
-        if value != expected_value:
-            raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
-
-    except Exception, e:
-        print '*** Failure test_device_value_get: %s' % str(e)
-        return False
-    return True
+	try:
+		d = device.Device()
+		d.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
+
+		m = d.models[63001][0]
+		p = 'int16_4'
+		value = m.points[p].value
+		expected_value = -20
+		if value != expected_value:
+			raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
+
+	except Exception as e:
+		print('*** Failure test_device_value_get: %s' % str(e))
+		return False
+	return True
 
 def test_device_value_set(pathlist=None):
-    try:
-        d = device.Device()
-        d.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
-
-        m = d.models[63001][0]
-        expected_value = -180
-        p = 'int16_4'
-        m.points[p].value = expected_value
-        value = m.points[p].value 
-        if value != expected_value:
-            raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
-
-    except Exception, e:
-        print '*** Failure test_device_value_get: %s' % str(e)
-        return False
-    return True
+	try:
+		d = device.Device()
+		d.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
+
+		m = d.models[63001][0]
+		expected_value = -180
+		p = 'int16_4'
+		m.points[p].value = expected_value
+		value = m.points[p].value 
+		if value != expected_value:
+			raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
+
+	except Exception as e:
+		print('*** Failure test_device_value_get: %s' % str(e))
+		return False
+	return True
 
 def test_device_common_len_65(pathlist=None):
-    try:
-        d = device.Device()
-        d.from_pics(filename='pics_test_device_2.xml', pathlist=pathlist)
-
-        m_1 = d.models[1][0]
-        expected_value = 'TestDevice-2'
-        p = 'Md'
-        value = m_1.points[p].value
-        if value != expected_value:
-            raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
-
-        m_63001 = d.models[63001][0]
-        expected_value = -180
-        p = 'int16_4'
-        m_63001.points[p].value = expected_value
-        value = m_63001.points[p].value 
-        if value != expected_value:
-            raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
-
-    except Exception, e:
-        print '*** Failure test_device_common_len_65: %s' % str(e)
-        return False
-    return True
+	try:
+		d = device.Device()
+		d.from_pics(filename='pics_test_device_2.xml', pathlist=pathlist)
+
+		m_1 = d.models[1][0]
+		expected_value = 'TestDevice-2'
+		p = 'Md'
+		value = m_1.points[p].value
+		if value != expected_value:
+			raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
+
+		m_63001 = d.models[63001][0]
+		expected_value = -180
+		p = 'int16_4'
+		m_63001.points[p].value = expected_value
+		value = m_63001.points[p].value 
+		if value != expected_value:
+			raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
+
+	except Exception as e:
+		print('*** Failure test_device_common_len_65: %s' % str(e))
+		return False
+	return True
 
 # verify all models in the default models directory can be read
 def test_device_models_smdx(pathlist=None):
 
-    path = device.model_type_path_default
-    try:
-        files = os.listdir(path)
-        model_id = None
-        for f in files:
-            try:
-                model_id = smdx.model_filename_to_id(f)
-                if model_id is not None:
-                    device.model_type_get(model_id)
-            except Exception, e:
-                raise Exception('Error scanning model %s: %s' % (str(model_id), e))
-    except Exception, e:
-        raise Exception('Error scanning model directory %s: %s' % (path, e))
-    return True
+	path = device.model_type_path_default
+	try:
+		files = os.listdir(path)
+		model_id = None
+		for f in files:
+			try:
+				model_id = smdx.model_filename_to_id(f)
+				if model_id is not None:
+					device.model_type_get(model_id)
+			except Exception as e:
+				raise Exception('Error scanning model %s: %s' % (str(model_id), e))
+	except Exception as e:
+		raise Exception('Error scanning model directory %s: %s' % (path, e))
+	return True
 
 def test_device_constant_sf(pathlist=None):
-    try:
-        d = device.Device()
-        d.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
-
-        m = d.models[63001][0]
-        p = 'uint32_4'
-        value = m.points[p].value
-        expected_value = 190
-        if value != expected_value:
-            raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
-
-    except Exception, e:
-        print '*** Failure test_device_constant_sf: %s' % str(e)
-        return False
-    return True
+	try:
+		d = device.Device()
+		d.from_pics(filename='pics_test_device_1.xml', pathlist=pathlist)
+
+		m = d.models[63001][0]
+		p = 'uint32_4'
+		value = m.points[p].value
+		expected_value = 190
+		if value != expected_value:
+			raise Exception("Value '%s' mismatch: %s %s" % (p, str(value), str(expected_value)))
+
+	except Exception as e:
+		print('*** Failure test_device_constant_sf: %s' % str(e))
+		return False
+	return True
 
 test_device_tests = [
-    test_device_modeltype,
-    test_device_pointtype,
-    test_device_pointtype_not_equal,
-    test_device_blocktype_not_equal,
-    test_device_modeltype_not_equal,
-    test_device_from_pics,
-    test_device_to_pics,
-    test_device_value_get,
-    test_device_value_set,
-    test_device_common_len_65,
-    test_device_models_smdx,
-    test_device_constant_sf
+	test_device_modeltype,
+	test_device_pointtype,
+	test_device_pointtype_not_equal,
+	test_device_blocktype_not_equal,
+	test_device_modeltype_not_equal,
+	test_device_from_pics,
+	test_device_to_pics,
+	test_device_value_get,
+	test_device_value_set,
+	test_device_common_len_65,
+	test_device_models_smdx,
+	test_device_constant_sf
 ]
 
 def test_all(pathlist=None, stop_on_failure=True):
 
-    if pathlist is not None:
-        device.file_pathlist = pathlist
-    else:
-        device.file_pathlist = util.PathList(['.', os.path.join(os.path.dirname(os.path.abspath(__file__)), 'devices')])
+	if pathlist is not None:
+		device.file_pathlist = pathlist
+	else:
+		device.file_pathlist = util.PathList(['.', os.path.join(os.path.dirname(os.path.abspath(__file__)), 'devices')])
 
-    count_passed = 0
-    count_failed = 0
-    count_run = 0
+	count_passed = 0
+	count_failed = 0
+	count_run = 0
 
-    for test in test_device_tests:
-        count_run += 1
-        if test(pathlist) is True:
-            count_passed += 1
-        else:
-            count_failed += 1
-            if stop_on_failure is True:
-                break
+	for test in test_device_tests:
+		count_run += 1
+		if test(pathlist) is True:
+			count_passed += 1
+		else:
+			count_failed += 1
+			if stop_on_failure is True:
+				break
 
-    print 'Test device module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(test_device_tests), count_run, count_passed, count_failed)
+	print('Test device module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(test_device_tests), count_run, count_passed, count_failed))
 
-    return (count_run, count_passed, count_failed)
+	return (count_run, count_passed, count_failed)
 
 if __name__ == "__main__":
 
diff --git a/sunspec/core/test/test_modbus_client.py b/sunspec/core/test/test_modbus_client.py
index b51844d..f5dffa0 100644
--- a/sunspec/core/test/test_modbus_client.py
+++ b/sunspec/core/test/test_modbus_client.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2016 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2016 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sys
@@ -28,139 +28,139 @@ import sunspec.core.device as device
 import sunspec.core.modbus.client as modbus
 
 def test_trace_func(s):
-    print s
+	print(s)
 
 def test_modbus_client_device_rtu_read(pathlist=None):
-    """
-    -> 01 03 9C 40 00 02 EB 8F
-    <- 01 03 04 53 75 6E 53 96 F0
-    """
+	"""
+	-> 01 03 9C 40 00 02 EB 8F
+	<- 01 03 04 53 75 6E 53 96 F0
+	"""
 
-    try:
-        d = modbus.ModbusClientDeviceRTU(1, modbus.TEST_NAME, trace_func=None)
+	try:
+		d = modbus.ModbusClientDeviceRTU(1, modbus.TEST_NAME, trace_func=None)
 
-        d.client.serial.in_buf = '\x01\x03\x04\x53\x75\x6E\x53\x96\xF0'
-        d.client.serial.out_buf = ''
+		d.client.serial.in_buf = '\x01\x03\x04\x53\x75\x6E\x53\x96\xF0'
+		d.client.serial.out_buf = ''
 
-        data = d.read(40000, 2)
+		data = d.read(40000, 2)
 
-        if d.client.serial.out_buf != '\x01\x03\x9C\x40\x00\x02\xEB\x8F':
-            raise Exception("Modbus request mismatch")
+		if d.client.serial.out_buf != '\x01\x03\x9C\x40\x00\x02\xEB\x8F':
+			raise Exception("Modbus request mismatch")
 
-        if data != 'SunS':
-            raise Exception("Read data mismatch - expected: 'SunS' received: %s") % (data)
+		if data != 'SunS':
+			raise Exception("Read data mismatch - expected: 'SunS' received: %s") % (data)
 
-        d.close()
+		d.close()
 
-    except Exception, e:
-        print '*** Failure test_modbus_client_device_rtu_read: %s' % str(e)
-        return False
-    return True
+	except Exception as e:
+		print('*** Failure test_modbus_client_device_rtu_read: %s' % str(e))
+		return False
+	return True
 
 def test_modbus_client_device_rtu_write(pathlist=None):
-    """
-    -> 01 10 9C 40 00 02 04 41 42 43 44 8B B2
-    <- 01 10 9C 40 00 02 6E 4C
-    """
+	"""
+	-> 01 10 9C 40 00 02 04 41 42 43 44 8B B2
+	<- 01 10 9C 40 00 02 6E 4C
+	"""
 
-    try:
-        d = modbus.ModbusClientDeviceRTU(1, modbus.TEST_NAME, trace_func=None)
+	try:
+		d = modbus.ModbusClientDeviceRTU(1, modbus.TEST_NAME, trace_func=None)
 
-        d.client.serial.in_buf = '\x01\x10\x9C\x40\x00\x02\x6E\x4C'
-        d.client.serial.out_buf = ''
+		d.client.serial.in_buf = '\x01\x10\x9C\x40\x00\x02\x6E\x4C'
+		d.client.serial.out_buf = ''
 
-        d.write(40000, 'ABCD')
+		d.write(40000, 'ABCD')
 
-        if d.client.serial.out_buf != '\x01\x10\x9C\x40\x00\x02\x04\x41\x42\x43\x44\x8B\xB2':
-            raise Exception("Modbus request mismatch")
+		if d.client.serial.out_buf != '\x01\x10\x9C\x40\x00\x02\x04\x41\x42\x43\x44\x8B\xB2':
+			raise Exception("Modbus request mismatch")
 
-        d.close()
+		d.close()
 
-    except Exception, e:
-        print '*** test_modbus_client_device_rtu_write: %s' % str(e)
-        return False
-    return True
+	except Exception as e:
+		print('*** test_modbus_client_device_rtu_write: %s' % str(e))
+		return False
+	return True
 
 def test_modbus_client_device_tcp_read(pathlist=None):
-    """
-    -> 00 00 00 00 00 06 01 03 9C 40 00 02
-    <- 00 00 00 00 00 07 01 03 04 53 75 6E 53
-    """
+	"""
+	-> 00 00 00 00 00 06 01 03 9C 40 00 02
+	<- 00 00 00 00 00 07 01 03 04 53 75 6E 53
+	"""
 
-    try:
-        d = modbus.ModbusClientDeviceTCP(1, ipaddr="127.0.0.1", trace_func=None, test=True)
+	try:
+		d = modbus.ModbusClientDeviceTCP(1, ipaddr="127.0.0.1", trace_func=None, test=True)
 
-        d.socket.in_buf = '\x00\x00\x00\x00\x00\x07\x01\x03\x04\x53\x75\x6E\x53'
-        d.socket.out_buf = ''
+		d.socket.in_buf = '\x00\x00\x00\x00\x00\x07\x01\x03\x04\x53\x75\x6E\x53'
+		d.socket.out_buf = ''
 
-        data = d.read(40000, 2)
+		data = d.read(40000, 2)
 
-        if d.socket.out_buf != '\x00\x00\x00\x00\x00\x06\x01\x03\x9C\x40\x00\x02':
-            raise Exception("Modbus request mismatch")
+		if d.socket.out_buf != '\x00\x00\x00\x00\x00\x06\x01\x03\x9C\x40\x00\x02':
+			raise Exception("Modbus request mismatch")
 
-        if data != 'SunS':
-            raise Exception("Read data mismatch - expected: 'SunS' received: %s") % (data)
+		if data != 'SunS':
+			raise Exception("Read data mismatch - expected: 'SunS' received: %s") % (data)
 
-        d.close()
+		d.close()
 
-    except Exception, e:
-        raise
-        print '*** Failure test_modbus_client_device_tcp_read: %s' % str(e)
-        return False
-    return True
+	except Exception as e:
+		raise
+		print('*** Failure test_modbus_client_device_tcp_read: %s' % str(e))
+		return False
+	return True
 
 def test_modbus_client_device_tcp_write(pathlist=None):
-    """
-    -> 00 00 00 00 00 0B 01 10 9C 40 00 02 04 41 42 43 44
-    <- 00 00 00 00 00 06 01 10 9C 40 00 02
-    """
+	"""
+	-> 00 00 00 00 00 0B 01 10 9C 40 00 02 04 41 42 43 44
+	<- 00 00 00 00 00 06 01 10 9C 40 00 02
+	"""
 
-    try:
-        d = modbus.ModbusClientDeviceTCP(1, ipaddr="127.0.0.1", trace_func=None, test=True)
+	try:
+		d = modbus.ModbusClientDeviceTCP(1, ipaddr="127.0.0.1", trace_func=None, test=True)
 
-        d.socket.in_buf = '\x00\x00\x00\x00\x00\x06\x01\x10\x9C\x40\x00\x02'
-        d.socket.out_buf = ''
+		d.socket.in_buf = '\x00\x00\x00\x00\x00\x06\x01\x10\x9C\x40\x00\x02'
+		d.socket.out_buf = ''
 
-        d.write(40000, 'ABCD')
+		d.write(40000, 'ABCD')
 
-        if d.socket.out_buf != '\x00\x00\x00\x00\x00\x0B\x01\x10\x9C\x40\x00\x02\x04\x41\x42\x43\x44':
-            raise Exception("Modbus request mismatch")
+		if d.socket.out_buf != '\x00\x00\x00\x00\x00\x0B\x01\x10\x9C\x40\x00\x02\x04\x41\x42\x43\x44':
+			raise Exception("Modbus request mismatch")
 
-        d.close()
-        
-    except Exception, e:
-        print '*** Failure test_modbus_client_device_tcp_write: %s' % str(e)
-        return False
-    return True
+		d.close()
+		
+	except Exception as e:
+		print('*** Failure test_modbus_client_device_tcp_write: %s' % str(e))
+		return False
+	return True
 
 tests = [
-    test_modbus_client_device_rtu_read,
-    test_modbus_client_device_rtu_write,
-    test_modbus_client_device_tcp_read,
-    test_modbus_client_device_tcp_write
+	test_modbus_client_device_rtu_read,
+	test_modbus_client_device_rtu_write,
+	test_modbus_client_device_tcp_read,
+	test_modbus_client_device_tcp_write
 ]
 
 def test_all(pathlist=None, stop_on_failure=True):
 
-    count_passed = 0
-    count_failed = 0
-    count_run = 0
+	count_passed = 0
+	count_failed = 0
+	count_run = 0
 
-    for test in tests:
-        count_run += 1
-        if test(pathlist) is True:
-            count_passed += 1
-        else:
-            count_failed += 1
-            if stop_on_failure is True:
-                break
+	for test in tests:
+		count_run += 1
+		if test(pathlist) is True:
+			count_passed += 1
+		else:
+			count_failed += 1
+			if stop_on_failure is True:
+				break
 
-    print 'Test modbus client module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(tests), count_run, count_passed, count_failed)
+	print('Test modbus client module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(tests), count_run, count_passed, count_failed))
 
-    return (count_run, count_passed, count_failed)
+	return (count_run, count_passed, count_failed)
 
 if __name__ == "__main__":
 
-    (count_run, count_passed, count_failed) = test_all()
-    sys.exit(count_failed)
+	(count_run, count_passed, count_failed) = test_all()
+	sys.exit(count_failed)
 
diff --git a/sunspec/core/test/test_modbus_mbmap.py b/sunspec/core/test/test_modbus_mbmap.py
index b8eb78d..d09ede2 100644
--- a/sunspec/core/test/test_modbus_mbmap.py
+++ b/sunspec/core/test/test_modbus_mbmap.py
@@ -1,33 +1,33 @@
 
 """
-    Copyright (C) 2016 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2016 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import sys
 import os
 
 try:
-    import xml.etree.ElementTree as ET
+	import xml.etree.ElementTree as ET
 except:
-    import elementtree.ElementTree as ET
+	import elementtree.ElementTree as ET
 
 import sunspec.core.device as device
 import sunspec.core.util as util
@@ -35,97 +35,97 @@ import sunspec.core.modbus.mbmap as mbmap
 
 def test_modbus_mbmap_from_xml_file(pathlist=None):
 
-    try:
-        m1 = mbmap.ModbusMap()
-        m1.from_xml('mbmap_test_device_1.xml', pathlist)
-
-        m2 = mbmap.ModbusMap()
-        m2.from_xml('mbmap_test_device_1_a.xml', pathlist)
-        not_equal =  m1.not_equal(m2)
-        if not_equal:
-            raise Exception(not_equal)
-
-        m3 = mbmap.ModbusMap()
-        m3.from_xml('mbmap_test_device_1_b.xml', pathlist)
-        not_equal =  m1.not_equal(m3)
-        if not_equal:
-            raise Exception(not_equal)
-
-        m4 = mbmap.ModbusMap()
-        m4.from_xml('mbmap_test_device_1_c.xml', pathlist)
-        not_equal =  m1.not_equal(m4)
-        if not_equal:
-            raise Exception(not_equal)
-
-    except Exception, e:
-        print '*** Failure test_modbus_mbmap_from_xml: %s' % str(e)
-        return False
-    return True
+	try:
+		m1 = mbmap.ModbusMap()
+		m1.from_xml('mbmap_test_device_1.xml', pathlist)
+
+		m2 = mbmap.ModbusMap()
+		m2.from_xml('mbmap_test_device_1_a.xml', pathlist)
+		not_equal =  m1.not_equal(m2)
+		if not_equal:
+			raise Exception(not_equal)
+
+		m3 = mbmap.ModbusMap()
+		m3.from_xml('mbmap_test_device_1_b.xml', pathlist)
+		not_equal =  m1.not_equal(m3)
+		if not_equal:
+			raise Exception(not_equal)
+
+		m4 = mbmap.ModbusMap()
+		m4.from_xml('mbmap_test_device_1_c.xml', pathlist)
+		not_equal =  m1.not_equal(m4)
+		if not_equal:
+			raise Exception(not_equal)
+
+	except Exception as e:
+		print('*** Failure test_modbus_mbmap_from_xml: %s' % str(e))
+		return False
+	return True
 
 def test_modbus_mbmap_from_xml_element(pathlist=None):
 
-    try:
-        filename = os.path.join(pathlist.path[1], 'mbmap_test_device_1.xml')
+	try:
+		filename = os.path.join(pathlist.path[1], 'mbmap_test_device_1.xml')
 
-        f = open(filename, 'r')
-        map_data = f.read()
-        f.close()
-        root = ET.fromstring(map_data)
+		f = open(filename, 'r')
+		map_data = f.read()
+		f.close()
+		root = ET.fromstring(map_data)
 
-        m1 = mbmap.ModbusMap()
-        m1.from_xml(element=root)
+		m1 = mbmap.ModbusMap()
+		m1.from_xml(element=root)
 
-        m2 = mbmap.ModbusMap()
-        m2.from_xml('mbmap_test_device_1_a.xml', pathlist)
-        not_equal =  m1.not_equal(m2)
-        if not_equal:
-            raise Exception(not_equal)
+		m2 = mbmap.ModbusMap()
+		m2.from_xml('mbmap_test_device_1_a.xml', pathlist)
+		not_equal =  m1.not_equal(m2)
+		if not_equal:
+			raise Exception(not_equal)
 
-        m3 = mbmap.ModbusMap()
-        m3.from_xml('mbmap_test_device_1_b.xml', pathlist)
-        not_equal =  m1.not_equal(m3)
-        if not_equal:
-            raise Exception(not_equal)
+		m3 = mbmap.ModbusMap()
+		m3.from_xml('mbmap_test_device_1_b.xml', pathlist)
+		not_equal =  m1.not_equal(m3)
+		if not_equal:
+			raise Exception(not_equal)
 
-        m4 = mbmap.ModbusMap()
-        m4.from_xml('mbmap_test_device_1_c.xml', pathlist)
-        not_equal =  m1.not_equal(m4)
-        if not_equal:
-            raise Exception(not_equal)
+		m4 = mbmap.ModbusMap()
+		m4.from_xml('mbmap_test_device_1_c.xml', pathlist)
+		not_equal =  m1.not_equal(m4)
+		if not_equal:
+			raise Exception(not_equal)
 
-    except Exception, e:
-        print '*** Failure test_modbus_mbmap_from_xml: %s' % str(e)
-        return False
-    return True
+	except Exception as e:
+		print('*** Failure test_modbus_mbmap_from_xml: %s' % str(e))
+		return False
+	return True
 
 tests = [
-    test_modbus_mbmap_from_xml_file,
-    test_modbus_mbmap_from_xml_element,]
+	test_modbus_mbmap_from_xml_file,
+	test_modbus_mbmap_from_xml_element,]
 
 def test_all(pathlist=None, stop_on_failure=True):
 
-    if pathlist is None:
-        pathlist = util.PathList(['.', os.path.join(os.path.dirname(os.path.abspath(__file__)), 'devices')])
+	if pathlist is None:
+		pathlist = util.PathList(['.', os.path.join(os.path.dirname(os.path.abspath(__file__)), 'devices')])
 
-    count_passed = 0
-    count_failed = 0
-    count_run = 0
+	count_passed = 0
+	count_failed = 0
+	count_run = 0
 
-    for test in tests:
-        count_run += 1
-        if test(pathlist) is True:
-            count_passed += 1
-        else:
-            count_failed += 1
-            if stop_on_failure is True:
-                break
+	for test in tests:
+		count_run += 1
+		if test(pathlist) is True:
+			count_passed += 1
+		else:
+			count_failed += 1
+			if stop_on_failure is True:
+				break
 
-    print 'Test modbus mbmap module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(tests), count_run, count_passed, count_failed)
+	print('Test modbus mbmap module: total tests: %d  tests run: %d  tests passed: %d  tests failed: %d' %  (len(tests), count_run, count_passed, count_failed))
 
-    return (count_run, count_passed, count_failed)
+	return (count_run, count_passed, count_failed)
 
 if __name__ == "__main__":
 
-    (count_run, count_passed, count_failed) = test_all()
-    sys.exit(count_failed)
+	(count_run, count_passed, count_failed) = test_all()
+	sys.exit(count_failed)
 
diff --git a/sunspec/core/util.py b/sunspec/core/util.py
index 27b9898..d6f2a60 100644
--- a/sunspec/core/util.py
+++ b/sunspec/core/util.py
@@ -1,24 +1,24 @@
 
 """
-    Copyright (C) 2017 SunSpec Alliance
-
-    Permission is hereby granted, free of charge, to any person obtaining a
-    copy of this software and associated documentation files (the "Software"),
-    to deal in the Software without restriction, including without limitation
-    the rights to use, copy, modify, merge, publish, distribute, sublicense,
-    and/or sell copies of the Software, and to permit persons to whom the
-    Software is furnished to do so, subject to the following conditions:
-
-    The above copyright notice and this permission notice shall be included
-    in all copies or substantial portions of the Software.
-
-    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
-    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
-    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
-    IN THE SOFTWARE.
+	Copyright (C) 2017 SunSpec Alliance
+
+	Permission is hereby granted, free of charge, to any person obtaining a
+	copy of this software and associated documentation files (the "Software"),
+	to deal in the Software without restriction, including without limitation
+	the rights to use, copy, modify, merge, publish, distribute, sublicense,
+	and/or sell copies of the Software, and to permit persons to whom the
+	Software is furnished to do so, subject to the following conditions:
+
+	The above copyright notice and this permission notice shall be included
+	in all copies or substantial portions of the Software.
+
+	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
+	THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+	FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
+	IN THE SOFTWARE.
 """
 
 import os
@@ -27,223 +27,223 @@ import zipfile
 import array
 
 class SunSpecError(Exception):
-    pass
+	pass
 
 """ Functions to pack and unpack data string values
 
 """
 def data_to_s16(data):
-    s16 = struct.unpack('>h', data)
-    return s16[0]
+	s16 = struct.unpack('>h', data)
+	return s16[0]
 
 def data_to_u16(data):
-    u16 = struct.unpack('>H', data)
-    return u16[0]
+	u16 = struct.unpack('>H', data)
+	return u16[0]
 
 def data_to_s32(data):
-    s32 = struct.unpack('>l', data)
-    return s32[0]
+	s32 = struct.unpack('>l', data)
+	return s32[0]
 
 def data_to_u32(data):
-    u32 = struct.unpack('>L', data)
-    return u32[0]
+	u32 = struct.unpack('>L', data)
+	return u32[0]
 
 def data_to_s64(data):
-    s64 = struct.unpack('>q', data)
-    return s64[0]
+	s64 = struct.unpack('>q', data)
+	return s64[0]
 
 def data_to_u64(data):
-    u64 = struct.unpack('>Q', data)
-    return u64[0]
+	u64 = struct.unpack('>Q', data)
+	return u64[0]
 
 def data_to_ipv6addr(data):
-    addr = struct.unpack('16s', data)
-    return addr[0]
+	addr = struct.unpack('16s', data)
+	return addr[0]
 
 def data_to_eui48(data):
-    return '%02X:%02X:%02X:%02X:%02X:%02X' % (ord(data[2]), ord(data[3]), ord(data[4]), ord(data[5]), ord(data[6]), ord(data[7]))
+	return '%02X:%02X:%02X:%02X:%02X:%02X' % (ord(data[2]), ord(data[3]), ord(data[4]), ord(data[5]), ord(data[6]), ord(data[7]))
 
 try:
-    float('nan')
+	float('nan')
 
-    def data_to_float(data):
-        f = struct.unpack('>f', data)
-        return f[0]
+	def data_to_float(data):
+		f = struct.unpack('>f', data)
+		return f[0]
 
-    def data_to_double(data):
-        d = struct.unpack('>d', data)
-        return d[0]
+	def data_to_double(data):
+		d = struct.unpack('>d', data)
+		return d[0]
 
 except Exception:
-    # earlier python version - nan not supported
-    def data_to_float(data):
-        e = struct.unpack('>L', data)
-        # if all exponent bits are '1' it is nan or inf, set to None
-        if (e[0] & 0x7f800000) == 0x7f800000:
-            return None
-        else:
-            f = struct.unpack('>f', data)
-        return f[0]
-
-    def data_to_double(data):
-        e = struct.unpack('>Q', data)
-        # if all exponent bits are '1' it is nan or inf, set to None
-        if (e[0] & 0x7ff0000000000000) == 0x7ff0000000000000:
-            return None
-        else:
-            d = struct.unpack('>d', data)
-        return d[0]
+	# earlier python version - nan not supported
+	def data_to_float(data):
+		e = struct.unpack('>L', data)
+		# if all exponent bits are '1' it is nan or inf, set to None
+		if (e[0] & 0x7f800000) == 0x7f800000:
+			return None
+		else:
+			f = struct.unpack('>f', data)
+		return f[0]
+
+	def data_to_double(data):
+		e = struct.unpack('>Q', data)
+		# if all exponent bits are '1' it is nan or inf, set to None
+		if (e[0] & 0x7ff0000000000000) == 0x7ff0000000000000:
+			return None
+		else:
+			d = struct.unpack('>d', data)
+		return d[0]
 
 def data_to_str(data):
-    if len(data) > 1:
-        data = data[0] + data[1:].rstrip('\0')
-    return data
+	if len(data) > 1:
+		data = data[0] + data[1:].rstrip('\0')
+	return data
 
 def s16_to_data(s16, len=None):
-    return struct.pack('>h', s16)
+	return struct.pack('>h', s16)
 
 def u16_to_data(u16, len=None):
-    return struct.pack('>H', u16)
+	return struct.pack('>H', u16)
 
 def s32_to_data(s32, len=None):
-    return struct.pack('>l', s32)
+	return struct.pack('>l', s32)
 
 def u32_to_data(u32, len=None):
-    return struct.pack('>L', u32)
+	return struct.pack('>L', u32)
 
 def s64_to_data(s64, len=None):
-    return struct.pack('>q', s64)
+	return struct.pack('>q', s64)
 
 def u64_to_data(u64, len=None):
-    return struct.pack('>Q', u64)
+	return struct.pack('>Q', u64)
 
 def ipv6addr_to_data(addr, len=None):
-    return struct.pack('16s', addr)
+	return struct.pack('16s', addr)
 
 def float_to_data32(f, len=None):
-    # convert python float (float64) to float32 before packing
-    fa = array('f', f)
-    return struct.pack('>f', fa[0])
+	# convert python float (float64) to float32 before packing
+	fa = array('f', f)
+	return struct.pack('>f', fa[0])
 
 def float32_to_data(f, len=None):
-    return struct.pack('>f', f)
+	return struct.pack('>f', f)
 
 def float_to_data(f, len=None):
-    # python float is really a double
-    return struct.pack('>d', f)
+	# python float is really a double
+	return struct.pack('>d', f)
 
 def str_to_data(s, slen=None):
-    if slen is None:
-        slen = len(s)
-    return struct.pack(str(slen) + 's', s)
+	if slen is None:
+		slen = len(s)
+	return struct.pack(str(slen) + 's', s)
 
 def eui48_to_data(eui48):
-    return ('0000' + eui48.replace(':', '')).decode('hex')
+	return ('0000' + eui48.replace(':', '')).decode('hex')
 
 """ Simple XML pretty print support function
 
 """
 def indent(elem, level=0):
-    i = "\n" + level*"  "
-    if len(elem):
-        if not elem.text or not elem.text.strip():
-            elem.text = i + "  "
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-        for elem in elem:
-            indent(elem, level+1)
-        if not elem.tail or not elem.tail.strip():
-            elem.tail = i
-    else:
-        if level and (not elem.tail or not elem.tail.strip()):
-            elem.tail = i
+	i = "\n" + level*"  "
+	if len(elem):
+		if not elem.text or not elem.text.strip():
+			elem.text = i + "  "
+		if not elem.tail or not elem.tail.strip():
+			elem.tail = i
+		for elem in elem:
+			indent(elem, level+1)
+		if not elem.tail or not elem.tail.strip():
+			elem.tail = i
+	else:
+		if level and (not elem.tail or not elem.tail.strip()):
+			elem.tail = i
 
 """ File path list
 
 """
 class PathList(object):
 
-    def __init__(self, path_list=None):
-        self.path = []
-
-        if path_list is not None:
-            self.path = path_list
-
-    """ Add path to path list
-
-    Provides a list of file system paths to search for non-python files similar to sys.path for python 
-    modules. Zipfiles can be included in a path name and the contents of the zipfile will be searched
-    based on the remaining path content. Zip file support has the following restrictions: only one zip file
-    in a path, zi pfiles must have a .zip extension in the name, directories can not end in .zip.
-    Paths are searched in the order they were added to the path list.
-
-    """
-    def add(self, path):
-
-        self.path.append(path)
-
-    """ Read first instance of specified file found in path list
-
-    Traverses the path list and returns the contents of the first instance of the specified file.
-    Supports zip files in path.
-
-    """
-    def read(self, filename):
-
-        file_path = ''
-        zip_file_path = ''
-
-        # traverse path list until first instance of file found
-        for p in self.path:
-            file_path = ''
-            element_list = p.split(os.sep)
-            sep = os.sep
-
-            for e in element_list:
-                if e == '':
-                    file_path += sep
-                elif file_path and file_path != sep:
-                    file_path += sep
-                file_path += e
-                if e.endswith('.zip'):
-                    zip_file_path = file_path
-                    if os.path.exists(zip_file_path):
-                        file_path = ''
-                        # zip file separator is always '/'
-                        sep = '/'
-                    else:
-                        # continue with next path list element if zip file does not exist
-                        zip_file_path = ''
-                        break
-
-            if file_path and file_path != os.sep:
-                file_path += sep
-            file_path  += filename
-            if zip_file_path:
-                zip_file = zipfile.ZipFile(zip_file_path)
-                try:
-                    zip_file.getinfo(file_path)
-                except Exception, e:
-                    continue
-                return zip_file.read(file_path)
-            else:
-                if os.path.exists(file_path):
-                    f = open(file_path, 'rb')
-                    return f.read()
-                else:
-                    continue
-
-        # file not found
-        raise NameError(filename)
-
-    def __str__(self):
-
-        paths = []
-
-        for p in self.path:
-            paths.append(p)
-
-        return str(paths)
+	def __init__(self, path_list=None):
+		self.path = []
+
+		if path_list is not None:
+			self.path = path_list
+
+	""" Add path to path list
+
+	Provides a list of file system paths to search for non-python files similar to sys.path for python 
+	modules. Zipfiles can be included in a path name and the contents of the zipfile will be searched
+	based on the remaining path content. Zip file support has the following restrictions: only one zip file
+	in a path, zi pfiles must have a .zip extension in the name, directories can not end in .zip.
+	Paths are searched in the order they were added to the path list.
+
+	"""
+	def add(self, path):
+
+		self.path.append(path)
+
+	""" Read first instance of specified file found in path list
+
+	Traverses the path list and returns the contents of the first instance of the specified file.
+	Supports zip files in path.
+
+	"""
+	def read(self, filename):
+
+		file_path = ''
+		zip_file_path = ''
+
+		# traverse path list until first instance of file found
+		for p in self.path:
+			file_path = ''
+			element_list = p.split(os.sep)
+			sep = os.sep
+
+			for e in element_list:
+				if e == '':
+					file_path += sep
+				elif file_path and file_path != sep:
+					file_path += sep
+				file_path += e
+				if e.endswith('.zip'):
+					zip_file_path = file_path
+					if os.path.exists(zip_file_path):
+						file_path = ''
+						# zip file separator is always '/'
+						sep = '/'
+					else:
+						# continue with next path list element if zip file does not exist
+						zip_file_path = ''
+						break
+
+			if file_path and file_path != os.sep:
+				file_path += sep
+			file_path  += filename
+			if zip_file_path:
+				zip_file = zipfile.ZipFile(zip_file_path)
+				try:
+					zip_file.getinfo(file_path)
+				except Exception as e:
+					continue
+				return zip_file.read(file_path)
+			else:
+				if os.path.exists(file_path):
+					f = open(file_path, 'rb')
+					return f.read()
+				else:
+					continue
+
+		# file not found
+		raise NameError(filename)
+
+	def __str__(self):
+
+		paths = []
+
+		for p in self.path:
+			paths.append(p)
+
+		return str(paths)
 
 
 
